// src/file/utils/palettes.ts
var generateGrayscalePalette = () => {
  const result = [];
  for (let i = 0; i <= 255; i++) {
    result.push(`rgb(${i},${i},${i})`);
  }
  return result;
};
var JET = [
  "rgb( 0, 0, 127 )",
  "rgb( 0, 0, 131)",
  "rgb( 0, 0, 135)",
  "rgb( 0, 0, 139)",
  "rgb( 0, 0, 143)",
  "rgb( 0, 0, 147)",
  "rgb( 0, 0, 151)",
  "rgb( 0, 0, 155)",
  "rgb( 0, 0, 159)",
  "rgb( 0, 0, 163)",
  "rgb( 0, 0, 167)",
  "rgb( 0, 0, 171)",
  "rgb( 0, 0, 175)",
  "rgb( 0, 0, 179)",
  "rgb( 0, 0, 183)",
  "rgb( 0, 0, 187)",
  "rgb( 0, 0, 191)",
  "rgb( 0, 0, 195)",
  "rgb( 0, 0, 199)",
  "rgb( 0, 0, 203)",
  "rgb( 0, 0, 207)",
  "rgb( 0, 0, 211)",
  "rgb( 0, 0, 215)",
  "rgb( 0, 0, 219)",
  "rgb( 0, 0, 223)",
  "rgb( 0, 0, 227)",
  "rgb( 0, 0, 231)",
  "rgb( 0, 0, 235)",
  "rgb( 0, 0, 239)",
  "rgb( 0, 0, 243)",
  "rgb( 0, 0, 247)",
  "rgb( 0, 0, 251)",
  "rgb( 0, 0, 255)",
  "rgb( 0, 4, 255)",
  "rgb( 0, 8, 255)",
  "rgb( 0, 12, 255)",
  "rgb( 0, 16, 255)",
  "rgb( 0, 20, 255)",
  "rgb( 0, 24, 255)",
  "rgb( 0, 28, 255)",
  "rgb( 0, 32, 255)",
  "rgb( 0, 36, 255)",
  "rgb( 0, 40, 255)",
  "rgb( 0, 44, 255)",
  "rgb( 0, 48, 255)",
  "rgb( 0, 52, 255)",
  "rgb( 0, 56, 255)",
  "rgb( 0, 60, 255)",
  "rgb( 0, 64, 255)",
  "rgb( 0, 68, 255)",
  "rgb( 0, 72, 255)",
  "rgb( 0, 76, 255)",
  "rgb( 0, 80, 255)",
  "rgb( 0, 84, 255)",
  "rgb( 0, 88, 255)",
  "rgb( 0, 92, 255)",
  "rgb( 0, 96, 255)",
  "rgb( 0, 100, 255)",
  "rgb( 0, 104, 255)",
  "rgb( 0, 108, 255)",
  "rgb( 0, 112, 255)",
  "rgb( 0, 116, 255)",
  "rgb( 0, 120, 255)",
  "rgb( 0, 124, 255)",
  "rgb( 0, 128, 255)",
  "rgb( 0, 132, 255)",
  "rgb( 0, 136, 255)",
  "rgb( 0, 140, 255)",
  "rgb( 0, 144, 255)",
  "rgb( 0, 148, 255)",
  "rgb( 0, 152, 255)",
  "rgb( 0, 156, 255)",
  "rgb( 0, 160, 255)",
  "rgb( 0, 164, 255)",
  "rgb( 0, 168, 255)",
  "rgb( 0, 172, 255)",
  "rgb( 0, 176, 255)",
  "rgb( 0, 180, 255)",
  "rgb( 0, 184, 255)",
  "rgb( 0, 188, 255)",
  "rgb( 0, 192, 255)",
  "rgb( 0, 196, 255)",
  "rgb( 0, 200, 255)",
  "rgb( 0, 204, 255)",
  "rgb( 0, 208, 255)",
  "rgb( 0, 212, 255)",
  "rgb( 0, 216, 255)",
  "rgb( 0, 220, 255)",
  "rgb( 0, 224, 255)",
  "rgb( 0, 228, 255)",
  "rgb( 0, 232, 255)",
  "rgb( 0, 236, 255)",
  "rgb( 0, 240, 255)",
  "rgb( 0, 244, 255)",
  "rgb( 0, 248, 255)",
  "rgb( 0, 252, 255)",
  "rgb( 1, 255, 253)",
  "rgb( 5, 255, 249)",
  "rgb( 9, 255, 245)",
  "rgb( 13, 255, 241)",
  "rgb( 17, 255, 237)",
  "rgb( 21, 255, 233)",
  "rgb( 25, 255, 229)",
  "rgb( 29, 255, 225)",
  "rgb( 33, 255, 221)",
  "rgb( 37, 255, 217)",
  "rgb( 41, 255, 213)",
  "rgb( 45, 255, 209)",
  "rgb( 49, 255, 205)",
  "rgb( 53, 255, 201)",
  "rgb( 57, 255, 197)",
  "rgb( 61, 255, 193)",
  "rgb( 65, 255, 189)",
  "rgb( 69, 255, 185)",
  "rgb( 73, 255, 181)",
  "rgb( 77, 255, 177)",
  "rgb( 81, 255, 173)",
  "rgb( 85, 255, 169)",
  "rgb( 89, 255, 165)",
  "rgb( 93, 255, 161)",
  "rgb( 97, 255, 157)",
  "rgb( 101, 255, 153)",
  "rgb( 105, 255, 149)",
  "rgb( 109, 255, 145)",
  "rgb( 113, 255, 141)",
  "rgb( 117, 255, 137)",
  "rgb( 121, 255, 133)",
  "rgb( 125, 255, 129)",
  "rgb( 129, 255, 125)",
  "rgb( 133, 255, 121)",
  "rgb( 137, 255, 117)",
  "rgb( 141, 255, 113)",
  "rgb( 145, 255, 109)",
  "rgb( 149, 255, 105)",
  "rgb( 153, 255, 101)",
  "rgb( 157, 255, 97)",
  "rgb( 161, 255, 93)",
  "rgb( 165, 255, 89)",
  "rgb( 169, 255, 85)",
  "rgb( 173, 255, 81)",
  "rgb( 177, 255, 77)",
  "rgb( 181, 255, 73)",
  "rgb( 185, 255, 69)",
  "rgb( 189, 255, 65)",
  "rgb( 193, 255, 61)",
  "rgb( 197, 255, 57)",
  "rgb( 201, 255, 53)",
  "rgb( 205, 255, 49)",
  "rgb( 209, 255, 45)",
  "rgb( 213, 255, 41)",
  "rgb( 217, 255, 37)",
  "rgb( 221, 255, 33)",
  "rgb( 225, 255, 29)",
  "rgb( 229, 255, 25)",
  "rgb( 233, 255, 21)",
  "rgb( 237, 255, 17)",
  "rgb( 241, 255, 13)",
  "rgb( 245, 255, 9)",
  "rgb( 249, 255, 5)",
  "rgb( 253, 255, 1)",
  "rgb( 255, 252, 1)",
  "rgb( 255, 248, 1)",
  "rgb( 255, 244, 1)",
  "rgb( 255, 240, 1)",
  "rgb( 255, 236, 1)",
  "rgb( 255, 232, 1)",
  "rgb( 255, 228, 1)",
  "rgb( 255, 224, 1)",
  "rgb( 255, 220, 1)",
  "rgb( 255, 216, 1)",
  "rgb( 255, 212, 1)",
  "rgb( 255, 208, 1)",
  "rgb( 255, 204, 1)",
  "rgb( 255, 200, 1)",
  "rgb( 255, 196, 1)",
  "rgb( 255, 192, 1)",
  "rgb( 255, 188, 1)",
  "rgb( 255, 184, 1)",
  "rgb( 255, 180, 1)",
  "rgb( 255, 176, 1)",
  "rgb( 255, 172, 1)",
  "rgb( 255, 168, 1)",
  "rgb( 255, 164, 1)",
  "rgb( 255, 160, 1)",
  "rgb( 255, 156, 1)",
  "rgb( 255, 152, 1)",
  "rgb( 255, 148, 1)",
  "rgb( 255, 144, 1)",
  "rgb( 255, 140, 1)",
  "rgb( 255, 136, 1)",
  "rgb( 255, 132, 1)",
  "rgb( 255, 128, 1)",
  "rgb( 255, 124, 1)",
  "rgb( 255, 120, 1)",
  "rgb( 255, 116, 1)",
  "rgb( 255, 112, 1)",
  "rgb( 255, 108, 1)",
  "rgb( 255, 104, 1)",
  "rgb( 255, 100, 1)",
  "rgb( 255, 96, 1)",
  "rgb( 255, 92, 1)",
  "rgb( 255, 88, 1)",
  "rgb( 255, 84, 1)",
  "rgb( 255, 80, 1)",
  "rgb( 255, 76, 1)",
  "rgb( 255, 72, 1)",
  "rgb( 255, 68, 1)",
  "rgb( 255, 64, 1)",
  "rgb( 255, 60, 1)",
  "rgb( 255, 56, 1)",
  "rgb( 255, 52, 1)",
  "rgb( 255, 48, 1)",
  "rgb( 255, 44, 1)",
  "rgb( 255, 40, 1)",
  "rgb( 255, 36, 1)",
  "rgb( 255, 32, 1)",
  "rgb( 255, 28, 1)",
  "rgb( 255, 24, 1)",
  "rgb( 255, 20, 1)",
  "rgb( 255, 16, 1)",
  "rgb( 255, 12, 1)",
  "rgb( 255, 8, 1)",
  "rgb( 255, 4, 1)",
  "rgb( 255, 0, 1)",
  "rgb( 251, 0, 1)",
  "rgb( 247, 0, 1)",
  "rgb( 243, 0, 1)",
  "rgb( 239, 0, 1)",
  "rgb( 235, 0, 1)",
  "rgb( 231, 0, 1)",
  "rgb( 227, 0, 1)",
  "rgb( 223, 0, 1)",
  "rgb( 219, 0, 1)",
  "rgb( 215, 0, 1)",
  "rgb( 211, 0, 1)",
  "rgb( 207, 0, 1)",
  "rgb( 203, 0, 1)",
  "rgb( 199, 0, 1)",
  "rgb( 195, 0, 1)",
  "rgb( 191, 0, 1)",
  "rgb( 187, 0, 1)",
  "rgb( 183, 0, 1)",
  "rgb( 179, 0, 1)",
  "rgb( 175, 0, 1)",
  "rgb( 171, 0, 1)",
  "rgb( 167, 0, 1)",
  "rgb( 163, 0, 1)",
  "rgb( 159, 0, 1)",
  "rgb( 155, 0, 1)",
  "rgb( 151, 0, 1)",
  "rgb( 147, 0, 1)",
  "rgb( 143, 0, 1)",
  "rgb( 139, 0, 1)",
  "rgb( 135, 0, 1)",
  "rgb( 131, 0, 1)",
  "rgb( 127, 0, 1)"
];
var IRON = [
  "rgb( 0, 0, 0 )",
  "rgb(0, 0, 13 )",
  "rgb(0, 0, 29 )",
  "rgb(0, 0, 39 )",
  "rgb(0, 0, 46 )",
  "rgb(0, 0, 53 )",
  "rgb(0, 0, 60 )",
  "rgb(0, 0, 67 )",
  "rgb(0, 0, 74 )",
  "rgb(0, 0, 81 )",
  "rgb(1, 0, 85 )",
  "rgb(2, 0, 89 )",
  "rgb(3, 0, 94 )",
  "rgb(4, 0, 98 )",
  "rgb(5, 0, 101 )",
  "rgb(6, 0, 105 )",
  "rgb(8, 0, 109 )",
  "rgb(10, 0, 113 )",
  "rgb(12, 0, 116 )",
  "rgb(13, 0, 118 )",
  "rgb(15, 0, 120 )",
  "rgb(18, 0, 121 )",
  "rgb(21, 0, 123 )",
  "rgb(24, 0, 126 )",
  "rgb(27, 0, 128 )",
  "rgb(30, 0, 130 )",
  "rgb(33, 0, 133 )",
  "rgb(37, 0, 135 )",
  "rgb(40, 0, 137 )",
  "rgb(44, 0, 138 )",
  "rgb(47, 0, 140 )",
  "rgb(50, 0, 141 )",
  "rgb(53, 0, 142 )",
  "rgb(57, 0, 144 )",
  "rgb(59, 0, 145 )",
  "rgb(62, 0, 147 )",
  "rgb(64, 0, 148 )",
  "rgb(67, 0, 149 )",
  "rgb(70, 0, 150 )",
  "rgb(72, 0, 150 )",
  "rgb(75, 0, 151 )",
  "rgb(78, 0, 151 )",
  "rgb(81, 0, 151 )",
  "rgb(84, 0, 152 )",
  "rgb(87, 0, 152 )",
  "rgb(90, 0, 153 )",
  "rgb(93, 0, 154 )",
  "rgb(96, 0, 155 )",
  "rgb(99, 0, 155 )",
  "rgb(102, 0, 155 )",
  "rgb(105, 0, 155 )",
  "rgb(108, 0, 156 )",
  "rgb(111, 0, 156 )",
  "rgb(113, 0, 157 )",
  "rgb(116, 0, 157 )",
  "rgb(119, 0, 157 )",
  "rgb(122, 0, 157 )",
  "rgb(125, 0, 157 )",
  "rgb(128, 0, 157 )",
  "rgb(131, 0, 157 )",
  "rgb(133, 0, 157 )",
  "rgb(136, 0, 157 )",
  "rgb(138, 0, 157 )",
  "rgb(141, 0, 157 )",
  "rgb(144, 0, 156 )",
  "rgb(148, 0, 156 )",
  "rgb(150, 0, 155 )",
  "rgb(153, 0, 155 )",
  "rgb(155, 0, 155 )",
  "rgb(158, 0, 155 )",
  "rgb(160, 0, 155 )",
  "rgb(162, 0, 155 )",
  "rgb(165, 0, 154 )",
  "rgb(167, 0, 154 )",
  "rgb(169, 0, 154 )",
  "rgb(171, 0, 153 )",
  "rgb(173, 0, 153 )",
  "rgb(175, 1, 152 )",
  "rgb(176, 1, 152 )",
  "rgb(177, 1, 151 )",
  "rgb(179, 1, 150 )",
  "rgb(181, 2, 149 )",
  "rgb(183, 2, 149 )",
  "rgb(184, 3, 149 )",
  "rgb(185, 4, 149 )",
  "rgb(187, 5, 148 )",
  "rgb(188, 5, 147 )",
  "rgb(190, 6, 146 )",
  "rgb(191, 6, 146 )",
  "rgb(192, 7, 145 )",
  "rgb(193, 8, 144 )",
  "rgb(194, 9, 143 )",
  "rgb(195, 11, 142 )",
  "rgb(196, 12, 141 )",
  "rgb(198, 13, 139 )",
  "rgb(199, 14, 138 )",
  "rgb(200, 16, 136 )",
  "rgb(202, 18, 134 )",
  "rgb(202, 19, 133 )",
  "rgb(204, 21, 131 )",
  "rgb(205, 22, 129 )",
  "rgb(206, 23, 126 )",
  "rgb(207, 25, 123 )",
  "rgb(208, 26, 121 )",
  "rgb(209, 28, 118 )",
  "rgb(210, 29, 116 )",
  "rgb(211, 31, 114 )",
  "rgb(212, 33, 111 )",
  "rgb(213, 35, 108 )",
  "rgb(214, 37, 104 )",
  "rgb(215, 38, 101 )",
  "rgb(216, 40, 98 )",
  "rgb(218, 43, 95 )",
  "rgb(219, 45, 91 )",
  "rgb(219, 47, 87 )",
  "rgb(220, 48, 82 )",
  "rgb(221, 50, 76 )",
  "rgb(222, 52, 71 )",
  "rgb(223, 53, 65 )",
  "rgb(224, 55, 59 )",
  "rgb(224, 56, 54 )",
  "rgb(225, 58, 48 )",
  "rgb(226, 60, 42 )",
  "rgb(227, 62, 37 )",
  "rgb(228, 64, 31 )",
  "rgb(228, 66, 28 )",
  "rgb(229, 67, 26 )",
  "rgb(230, 69, 23 )",
  "rgb(230, 71, 22 )",
  "rgb(231, 73, 19 )",
  "rgb(232, 74, 18 )",
  "rgb(232, 76, 16 )",
  "rgb(233, 77, 14 )",
  "rgb(234, 78, 12 )",
  "rgb(234, 80, 11 )",
  "rgb(235, 82, 10 )",
  "rgb(235, 84, 9 )",
  "rgb(236, 86, 8 )",
  "rgb(236, 87, 8 )",
  "rgb(237, 89, 7 )",
  "rgb(237, 91, 6 )",
  "rgb(238, 92, 5 )",
  "rgb(238, 94, 5 )",
  "rgb(239, 95, 4 )",
  "rgb(239, 97, 4 )",
  "rgb(240, 99, 3 )",
  "rgb(240, 100, 3 )",
  "rgb(241, 102, 3 )",
  "rgb(241, 103, 3 )",
  "rgb(241, 105, 2 )",
  "rgb(241, 106, 2 )",
  "rgb(241, 107, 2 )",
  "rgb(242, 109, 1 )",
  "rgb(242, 111, 1 )",
  "rgb(243, 112, 1 )",
  "rgb(243, 114, 1 )",
  "rgb(244, 115, 0 )",
  "rgb(244, 117, 0 )",
  "rgb(244, 119, 0 )",
  "rgb(244, 121, 0 )",
  "rgb(245, 123, 0 )",
  "rgb(245, 126, 0 )",
  "rgb(246, 128, 0 )",
  "rgb(246, 129, 0 )",
  "rgb(247, 131, 0 )",
  "rgb(247, 133, 0 )",
  "rgb(247, 135, 0 )",
  "rgb(248, 136, 0 )",
  "rgb(248, 137, 0 )",
  "rgb(248, 139, 0 )",
  "rgb(248, 140, 0 )",
  "rgb(249, 142, 0 )",
  "rgb(249, 143, 0 )",
  "rgb(249, 144, 0 )",
  "rgb(249, 146, 0 )",
  "rgb(250, 148, 0 )",
  "rgb(250, 150, 0 )",
  "rgb(251, 152, 0 )",
  "rgb(251, 155, 0 )",
  "rgb(252, 157, 0 )",
  "rgb(252, 159, 0 )",
  "rgb(253, 161, 0 )",
  "rgb(253, 163, 0 )",
  "rgb(253, 165, 0 )",
  "rgb(253, 168, 0 )",
  "rgb(253, 170, 0 )",
  "rgb(253, 172, 0 )",
  "rgb(253, 173, 0 )",
  "rgb(254, 175, 0 )",
  "rgb(254, 177, 0 )",
  "rgb(254, 178, 0 )",
  "rgb(254, 180, 0 )",
  "rgb(254, 182, 0 )",
  "rgb(254, 184, 0 )",
  "rgb(254, 186, 0 )",
  "rgb(254, 187, 0 )",
  "rgb(254, 189, 0 )",
  "rgb(254, 191, 0 )",
  "rgb(254, 193, 0 )",
  "rgb(254, 195, 0 )",
  "rgb(254, 197, 0 )",
  "rgb(254, 199, 0 )",
  "rgb(254, 200, 0 )",
  "rgb(254, 202, 1 )",
  "rgb(254, 203, 1 )",
  "rgb(254, 204, 2 )",
  "rgb(254, 206, 3 )",
  "rgb(254, 207, 4 )",
  "rgb(254, 209, 6 )",
  "rgb(254, 211, 8 )",
  "rgb(254, 213, 9 )",
  "rgb(254, 214, 11 )",
  "rgb(254, 216, 12 )",
  "rgb(255, 218, 14 )",
  "rgb(255, 219, 15 )",
  "rgb(255, 220, 19 )",
  "rgb(255, 221, 23 )",
  "rgb(255, 222, 27 )",
  "rgb(255, 224, 31 )",
  "rgb(255, 225, 35 )",
  "rgb(255, 226, 38 )",
  "rgb(255, 228, 42 )",
  "rgb(255, 229, 48 )",
  "rgb(255, 230, 53 )",
  "rgb(255, 231, 59 )",
  "rgb(255, 233, 65 )",
  "rgb(255, 234, 71 )",
  "rgb(255, 235, 76 )",
  "rgb(255, 237, 83 )",
  "rgb(255, 238, 89 )",
  "rgb(255, 239, 95 )",
  "rgb(255, 239, 102 )",
  "rgb(255, 240, 109 )",
  "rgb(255, 241, 115 )",
  "rgb(255, 241, 123 )",
  "rgb(255, 242, 132 )",
  "rgb(255, 243, 139 )",
  "rgb(255, 244, 146 )",
  "rgb(255, 244, 153 )",
  "rgb(255, 245, 160 )",
  "rgb(255, 245, 167 )",
  "rgb(255, 246, 174 )",
  "rgb(255, 247, 181 )",
  "rgb(255, 248, 187 )",
  "rgb(255, 248, 193 )",
  "rgb(255, 249, 198 )",
  "rgb(255, 249, 203 )",
  "rgb(255, 250, 209 )",
  "rgb(255, 251, 215 )",
  "rgb(255, 252, 221 )",
  "rgb(255, 253, 227 )",
  "rgb(255, 253, 232 )",
  "rgb(255, 254, 237 )",
  "rgb(255, 254, 242 )",
  "rgb(255, 255, 247 )",
  "rgb(255, 255, 249 )"
];
var GRAYSCALE = generateGrayscalePalette();
var ThermalPalettes = {
  iron: {
    pixels: IRON,
    name: "IRON",
    gradient: "linear-gradient(90deg, rgba(0,0,0,1) 0%, rgba(10,12,77,1) 30%, rgba(86,20,101,1) 49%, rgba(255,0,0,1) 64%, rgba(249,255,0,1) 84%, rgba(255,255,255,1) 100%)",
    slug: "iron"
  },
  jet: {
    pixels: JET,
    name: "JET",
    gradient: "linear-gradient(90deg, rgba(31,0,157,1) 0%, rgba(0,5,255,1) 8%, rgba(0,255,239,1) 36%, rgba(255,252,0,1) 66%, rgba(255,2,0,1) 94%, rgba(145,0,0,1) 100%)",
    slug: "jet"
  },
  grayscale: {
    pixels: GRAYSCALE,
    name: "Grayscale",
    gradient: "linear-gradient(90deg, rgba(0,0,0,1) 0%, rgba(255,255,255,1) 100%)",
    slug: "grayscale"
  }
};

// src/utils/time/formatting.ts
import { format, formatISO9075 } from "date-fns";

// src/utils/time/base.ts
var TimeUtilsBase = class {
  /** Convert an input to a date object */
  static inputToDate = (value) => {
    if (typeof value === "number") {
      const d = /* @__PURE__ */ new Date();
      d.setTime(value);
      return d;
    }
    return value;
  };
};

// src/utils/time/formatting.ts
var TimeFormat = class _TimeFormat extends TimeUtilsBase {
  /** YYYY-MM-DD */
  static isoDate = (value) => {
    value = _TimeFormat.inputToDate(value);
    return formatISO9075(value, { representation: "date" });
  };
  /** HH:MM:SS */
  static isoTime = (value) => {
    value = _TimeFormat.inputToDate(value);
    return formatISO9075(value, { representation: "time" });
  };
  /** YYYY-MM-DD HH:MM:SS */
  static isoComplete = (value) => {
    value = _TimeFormat.inputToDate(value);
    return formatISO9075(value);
  };
  /** HH:mm */
  static humanTime = (value, showSeconds = false) => {
    value = _TimeFormat.inputToDate(value);
    return format(value, showSeconds ? "HH:mm:ss" : "HH:mm");
  };
  /** j. M. ???? (y) */
  static humanDate = (value, includeYear = false) => {
    value = _TimeFormat.inputToDate(value);
    return format(value, includeYear ? "d. M." : "d. M. yyyy");
  };
  /** Range */
  static humanRangeDates(from, to) {
    from = _TimeFormat.inputToDate(from);
    to = _TimeFormat.inputToDate(to);
    if (from.getUTCDate() === to.getUTCDate()) {
      return _TimeFormat.humanDate(from);
    }
    return [
      _TimeFormat.humanDate(from),
      _TimeFormat.humanDate(to)
    ].join(" - ");
  }
  static human(date) {
    return `${_TimeFormat.humanDate(date)} ${_TimeFormat.humanTime(date, true)} `;
  }
};

// src/utils/time/periods.ts
var TimePeriod = /* @__PURE__ */ ((TimePeriod2) => {
  TimePeriod2["HOUR"] = "jednu hodinu";
  TimePeriod2["DAY"] = "jeden den";
  TimePeriod2["WEEK"] = "jeden t\xFDden";
  TimePeriod2["MONTH"] = "jeden m\u011Bs\xEDc";
  TimePeriod2["YEAR"] = "jeden rok";
  return TimePeriod2;
})(TimePeriod || {});

// src/utils/time/rounding.ts
import { addDays, addHours, addMonths, addYears, endOfDay, endOfHour, endOfMonth, endOfWeek, endOfYear, startOfDay, startOfHour, startOfMonth, startOfWeek, startOfYear } from "date-fns";
var TimeRound = class _TimeRound extends TimeUtilsBase {
  static down = (value, roundTo) => {
    if (roundTo === "jednu hodinu" /* HOUR */)
      return startOfHour(value);
    else if (roundTo === "jeden den" /* DAY */)
      return startOfDay(value);
    else if (roundTo === "jeden t\xFDden" /* WEEK */)
      return startOfWeek(value);
    else if (roundTo === "jeden m\u011Bs\xEDc" /* MONTH */)
      return startOfMonth(value);
    return startOfYear(value);
  };
  static up = (value, roundTo) => {
    if (roundTo === "jednu hodinu" /* HOUR */)
      return endOfHour(value);
    else if (roundTo === "jeden den" /* DAY */)
      return endOfDay(value);
    else if (roundTo === "jeden t\xFDden" /* WEEK */)
      return endOfWeek(value);
    else if (roundTo === "jeden m\u011Bs\xEDc" /* MONTH */)
      return endOfMonth(value);
    return endOfYear(value);
  };
  static pick = (value, period) => {
    return [
      _TimeRound.down(value, period),
      _TimeRound.up(value, period)
    ];
  };
  static modify = (value, amount, period) => {
    switch (period) {
      case "jednu hodinu" /* HOUR */:
        return addHours(value, amount);
      case "jeden den" /* DAY */:
        return addDays(value, amount);
      case "jeden t\xFDden" /* WEEK */:
        return addDays(value, amount * 7);
      case "jeden m\u011Bs\xEDc" /* MONTH */:
        return addMonths(value, amount);
      case "jeden rok" /* YEAR */:
        return addYears(value, amount);
    }
  };
};

// src/properties/callbacksManager.ts
var CallbacksManager = class extends Map {
  /** @deprecated use set method instead */
  add(key, callback) {
    this.set(key, callback);
  }
  call(...args) {
    this.forEach((fn) => fn(...args));
  }
};

// src/filters/FilterContainer.ts
var FilterContainer = class {
  constructor(parent) {
    this.parent = parent;
  }
  _layers = [];
  get layers() {
    return this._layers;
  }
  onLayers = new CallbacksManager();
  setLayers(layers) {
    if (layers.length !== this._layers.length) {
      this._layers = layers;
      this.onLayers.call(this.layers);
    }
  }
  getActiveFilters() {
    return this.layers.filter((layer) => layer.bypass === false);
  }
  addFilter(filter) {
    if (this.layers.includes(filter)) {
      console.error(`filter ${filter} is already in ${this.parent}`);
    }
    this._layers.push(filter);
    this.onLayers.call(this.layers);
  }
  removeFilter(filter) {
    if (this.layers.includes(filter)) {
      this._layers = this.layers.filter((layer) => layer !== filter);
      this.onLayers.call(this.layers);
    }
  }
  applyFilters() {
    this.parent.getInstances().forEach((instance) => {
      instance.applyAllAvailableFilters();
    });
  }
  getFiltersArray() {
  }
};

// src/properties/abstractProperty.ts
var AbstractProperty = class {
  constructor(parent, _initial) {
    this.parent = parent;
    this._initial = _initial;
    this._value = this.validate(this._initial);
  }
  _value;
  reset() {
    this.value = this._initial;
  }
  /** Get the current value @readonly */
  get value() {
    return this._value;
  }
  /** Set the value and call all listeners */
  set value(value) {
    this._value = this.validate(value);
    this.afterSetEffect(this._value);
    Object.values(this._listeners).forEach((listener) => listener(this._value));
  }
  _listeners = {};
  addListener(id, listener) {
    if (id in this._listeners) {
      delete this._listeners[id];
    }
    this._listeners[id] = listener;
  }
  removeListener(id) {
    if (id in this._listeners) {
      delete this._listeners[id];
    }
  }
  clearAllListeners() {
    this._listeners = {};
  }
};

// src/properties/analysis/analysis/internals/AbstractAnalysis.ts
var AbstractAnalysis = class {
  constructor(key, file, initialColor) {
    this.key = key;
    this.file = file;
    this._initialColor = initialColor;
    this.nameInitial = key;
    this._name = key;
    this.layerRoot = document.createElement("div");
    this.layerRoot.style.position = "absolute";
    this.layerRoot.style.top = "0px";
    this.layerRoot.style.left = "0px";
    this.layerRoot.style.width = "100%";
    this.layerRoot.style.height = "100%";
    this.layerRoot.style.overflow = "hidden";
    this.layerRoot.id = `analysis_${this.key}`;
    this.renderRoot.appendChild(this.layerRoot);
    this.onMoveOrResize.set("call recalculate values when a control point moves", () => {
      this.recalculateValues();
      this.onSerializableChange.call(this, "moveOrResize");
    });
    this.onSerializableChange.set("sync slots", () => {
      this.file.group.analysisSync.syncSlots(this.file);
    });
  }
  onSerializableChange = new CallbacksManager();
  serializedIsValid(input) {
    const splitted = input.split(";").map((segment) => segment.trim());
    if (splitted.length < 2) {
      return false;
    }
    if (!["point", "ellipsis", "rectangle"].includes(splitted[1])) {
      return false;
    }
    if (splitted[1] !== this.getType()) {
      return false;
    }
    return true;
  }
  /** Selection status */
  _selected = false;
  get selected() {
    return this._selected;
  }
  onSelected = new CallbacksManager();
  onDeselected = new CallbacksManager();
  /** Actions taken when the value changes. Called internally by `this.recalculateValues()` */
  onValues = new CallbacksManager();
  /** Actions taken when the analysis moves or resizes anyhow. This is very much important and it is called from the edit tool. */
  onMoveOrResize = new CallbacksManager();
  /** The main DOM element of this analysis. Is placed in `this.renderRoot` */
  layerRoot;
  /** Alias of the file's canvasLayer root. The analysis DOM will be placed here. */
  get renderRoot() {
    return this.file.canvasLayer.getLayerRoot();
  }
  points = /* @__PURE__ */ new Map();
  _top;
  _left;
  _width;
  _height;
  get left() {
    return this._left;
  }
  get top() {
    return this._top;
  }
  /** This dimension does not count the last pixel. */
  get width() {
    return this._width;
  }
  /** This dimension does not count the last pixel. */
  get height() {
    return this._height;
  }
  get right() {
    return this._left + this._width;
  }
  get bottom() {
    return this._top + this._height;
  }
  setTop(value) {
    if (isNaN(value)) {
      return;
    }
    if (value === this.top) {
      return;
    }
    const { top, height } = this.getVerticalDimensionFromNewValue(value, "top");
    let shouldEmit = false;
    if (top !== this.top) {
      this._top = top;
      this.onSetTop(top);
      shouldEmit = true;
    }
    if (height !== this.height) {
      this._height = height;
      this.onSetHeight(height);
      shouldEmit = true;
    }
    if (shouldEmit) {
      this.onSerializableChange.call(this, "top");
    }
  }
  setLeft(value) {
    if (isNaN(value)) {
      return;
    }
    if (value === this.left) {
      return;
    }
    const { left, width } = this.getHorizontalDimensionsFromNewValue(value, "left");
    let shouldEmit = false;
    if (left !== this.left) {
      this._left = left;
      this.onSetLeft(left);
      shouldEmit = true;
    }
    if (width !== this.width) {
      this._width = width;
      this.onSetWidth(width);
      shouldEmit = true;
    }
    if (shouldEmit) {
      this.onSerializableChange.call(this, "left");
    }
  }
  setWidth(value) {
    if (value === this.height) {
      return;
    }
    const val = this.validateWidth(value);
    if (!isNaN(val) && val !== this.width) {
      this._width = val;
      this.onSetWidth(val);
      this.onSerializableChange.call(this, "width");
    }
  }
  setHeight(value) {
    if (value === this.height) {
      return;
    }
    const val = this.validateHeight(value);
    if (!isNaN(val) && val !== this.height) {
      this._height = val;
      this.onSetHeight(val);
      this.onSerializableChange.call(this, "height");
    }
  }
  setBottom(value) {
    if (isNaN(value)) {
      return;
    }
    if (value === this.bottom) {
      return;
    }
    const { top, height } = this.getVerticalDimensionFromNewValue(value, "bottom");
    let shouldEmit = false;
    if (top !== this.top) {
      this._top = top;
      this.onSetTop(top);
      shouldEmit = true;
    }
    ;
    if (height !== this.height) {
      this._height = height;
      this.onSetHeight(height);
      shouldEmit = true;
    }
    if (shouldEmit) {
      this.onSerializableChange.call(this, "bottom");
    }
  }
  setRight(value) {
    if (isNaN(value)) {
      return;
    }
    if (value === this.right) {
      return;
    }
    const { left, width } = this.getHorizontalDimensionsFromNewValue(value, "right");
    let shouldEmit = false;
    if (left !== this.left) {
      this._left = left;
      this.onSetLeft(left);
      shouldEmit = true;
    }
    if (width !== this.width) {
      this._width = width;
      this.onSetWidth(width);
      shouldEmit = true;
    }
    if (shouldEmit) {
      this.onSerializableChange.call(this, "right");
    }
  }
  /** Access all the file's analysis layers. */
  get layers() {
    return this.file.analysis.layers;
  }
  _min;
  get min() {
    return this._min;
  }
  _max;
  get max() {
    return this._max;
  }
  _avg;
  get avg() {
    return this._avg;
  }
  dangerouslySetValues(avg, min = void 0, max = void 0) {
    this._avg = avg;
    this._min = min;
    this._max = max;
    this.onValues.call(this.min, this.max, this.avg);
  }
  get arrayOfPoints() {
    return Array.from(this.points.values());
  }
  get arrayOfActivePoints() {
    return this.arrayOfPoints.filter((point) => point.active);
  }
  _color = "black";
  get color() {
    return this._color;
  }
  setColor(value) {
    this._color = value;
    this.setColorCallback(value);
    this.onSetColor.call(value);
  }
  onSetColor = new CallbacksManager();
  _initialColor;
  get initialColor() {
    return this._initialColor;
  }
  setInitialColor(value) {
    if (value === this.initialColor) {
      return;
    }
    this._initialColor = value;
    this.onSetInitialColor.call(value);
    this.onSerializableChange.call(this, "color");
    if (this.selected === true) {
      this.setColor(value);
    }
  }
  onSetInitialColor = new CallbacksManager();
  // public readonly initialColor: string;
  activeColor = "yellow";
  inactiveColor = "black";
  /** @deprecated is moved to GraphObject instead */
  get onGraphActivation() {
    return this.graph.onGraphActivation;
  }
  /** Indicated whether the analysis is in the state of initial creation (using mouse drag) or if it is already finalized. */
  ready = false;
  nameInitial;
  _name;
  get name() {
    return this._name;
  }
  setName(value) {
    if (value === this.name) {
      return;
    }
    this._name = value;
    this.onSerializableChange.call(this, "name");
    this.onSetName.call(value);
  }
  onSetName = new CallbacksManager();
  remove() {
    this.setDeselected();
    this.renderRoot.removeChild(this.layerRoot);
  }
  /** Selection / Deselection */
  setSelected(exclusive = false, emitGlobalEvent = true) {
    if (this.selected === true) {
      return;
    }
    this._selected = true;
    this.onSelected.call(this);
    this.setColor(this.initialColor);
    if (exclusive === true) {
      this.layers.all.filter((analysis) => analysis.key !== this.key).forEach((analysis) => {
        if (analysis.selected) {
          analysis.setDeselected(false);
        }
      });
    }
    if (emitGlobalEvent === true) {
      this.layers.onSelectionChange.call(this.layers.selectedOnly);
    }
    const slot = this.file.slots.getAnalysisSlot(this);
    if (slot) {
      this.file.group.analysisSync.setSlotSelected(this.file, slot);
    }
  }
  setDeselected(emitGlobalEvent = true) {
    if (this.selected === false) {
      return;
    }
    this._selected = false;
    this.onDeselected.call(this);
    this.setColor(this.inactiveColor);
    this.arrayOfActivePoints.forEach((point) => point.deactivate());
    if (emitGlobalEvent === true) {
      this.file.analysis.layers.onSelectionChange.call(this.file.analysis.layers.selectedOnly);
    }
    const slot = this.file.slots.getAnalysisSlot(this);
    if (slot) {
      this.file.group.analysisSync.setSlotDeselected(this.file, slot);
    }
  }
  /** Recalculate the analysis' values from the current position and dimensions. Called whenever the analysis is resized or whenever file's `pixels` change. */
  recalculateValues() {
    const { min, max, avg } = this.getValues();
    this._min = min;
    this._max = max;
    this._avg = avg;
    this.onValues.call(this.min, this.max, this.avg);
  }
  /** When parsing incoming serialized attribute, look if segments have an exact value */
  static serializedSegmentsHasExact(segments, lookup) {
    return segments.find((segment) => segment === lookup) ? true : false;
  }
  /** When parsing incooming serialized attribute, try to extract it by its key as string */
  static serializedGetStringValueByKey(segments, key) {
    const regexp = new RegExp(`${key}:*`);
    const item = segments.find((s) => {
      if (s.match(regexp)) {
        return isNaN(parseInt(s.split(":")[1]));
      }
    });
    return item?.split(":")[1].trim();
  }
  /** When parsing incooming serialized attribute, try to extract it by its key as number */
  static serializedGetNumericalValueByKey(segments, key) {
    const regexp = new RegExp(`${key}:\\d+`);
    const item = segments.find((s) => s.match(regexp));
    if (item === void 0) {
      return void 0;
    }
    return parseInt(item.split(":")[1]);
  }
};

// src/properties/analysis/analysis/internals/AbstractPoint.ts
var AbstractPoint = class {
  constructor(key, top, left, analysis, color, placementX, placementY) {
    this.key = key;
    this.analysis = analysis;
    this.pxX = 100 / this.analysis.file.width;
    this.pxY = 100 / this.analysis.file.height;
    this._x = left;
    this._y = top;
    this._color = color;
    this.container = document.createElement("div");
    this.container.style.position = "absolute";
    this.container.id = `analysis_${this.analysis.key}_${this.key}_${this.file.id}`;
    this.innerElement = this.createInnerElement();
    this.container.appendChild(this.innerElement);
    this.setColor(color);
    this.setXDirectly(left, placementX);
    this.setYDirectly(top, placementY);
    this.root.appendChild(this.container);
  }
  get file() {
    return this.analysis.file;
  }
  pxX;
  _x;
  get x() {
    return this._x;
  }
  onX = new CallbacksManager();
  pxY;
  _y;
  get y() {
    return this._y;
  }
  onY = new CallbacksManager();
  /** 
   * Recieves X from the tool. 
   * 
   * Needs to determine the placement using `analyzeXFromTool`. 
   * Calls `sideEffectOnXFromTool`.
   */
  setXFromTool(value) {
    const { x, placement } = this.analyzeXFromTool(value);
    if (this.mayMoveToX(x)) {
      const prev = this.x;
      this._x = x;
      const style = this.getXStyle(x, placement);
      this.container.style.left = style;
      this.sideEffectOnXFromTool(x, placement);
      this.onX.call(this.x, prev);
    }
  }
  /** Recieves the X directly, along with the placement, with no side effects. */
  setXDirectly(value, placement) {
    if (this.mayMoveToX(value)) {
      const prev = this.x;
      this._x = value;
      const style = this.getXStyle(value, placement);
      this.container.style.left = style;
      this.onX.call(this.x, prev);
    }
  }
  /** 
   * Recieves Y from the tool. 
   * 
   * Needs to determine the placement using `analyzeYFromTool`. 
   * Calls `sideEffectOnYFromTool`.
   */
  setYFromTool(value) {
    const { y, placement } = this.analyzeYFromTool(value);
    if (this.mayMoveToY(y)) {
      const prev = this.y;
      this._y = y;
      const style = this.getYStyle(y, placement);
      this.container.style.top = style;
      this.sideEffectOnYFromTool(y, placement);
      this.onY.call(this.y, prev);
    }
  }
  /** Recieves the Y directly, along with the placement, with no side effects. */
  setYDirectly(value, placement) {
    if (this.mayMoveToY(value)) {
      const prev = this.y;
      this._y = value;
      const style = this.getYStyle(value, placement);
      this.container.style.top = style;
      this.onY.call(this.y, prev);
    }
  }
  /** Format the `left` style from given position and placement */
  getXStyle(value, placement) {
    const percent = this.calculatePercentageX(value);
    const offset = placement === 1 /* START */ ? 0 : placement === 3 /* END */ ? this.pxX : this.pxX / 2;
    return this.formatPositionStyle(percent, offset);
  }
  getYStyle(value, placement) {
    const percent = this.calculatePercentageY(value);
    const offset = placement === 1 /* START */ ? 0 : placement === 3 /* END */ ? this.pxY : this.pxY / 2;
    return this.formatPositionStyle(percent, offset);
  }
  /** Convert a percentage and a offset in pixels into a CSS style string */
  formatPositionStyle(percent, offsetInPx) {
    if (offsetInPx === 0 || isNaN(offsetInPx)) {
      return `${percent}%`;
    }
    return `calc( ${percent}% + ${offsetInPx}% )`;
  }
  _color;
  get color() {
    return this._color;
  }
  setColor(value) {
    this._color = value;
    this.onSetColor(value);
  }
  get initialColor() {
    return this.analysis.initialColor;
  }
  get activeColor() {
    return this.analysis.activeColor;
  }
  get inactiveColor() {
    return this.analysis.inactiveColor;
  }
  _active = false;
  get active() {
    return this._active;
  }
  _isHover = false;
  get isHover() {
    return this._isHover;
  }
  _isDragging = false;
  get isDragging() {
    return this._isDragging;
  }
  get root() {
    return this.analysis.layerRoot;
  }
  /** The container is allways positioned by percents. The container dimension is allways 1x1. The container contains the inner element which handles the display. */
  container;
  /** The display element. */
  innerElement;
  isWithin(top, left) {
    const offset = this.getRadius() / 2;
    const minX = this.x - offset;
    const maxX = this.x + offset;
    const minY = this.y - offset;
    const maxY = this.y + offset;
    return left >= minX && left <= maxX && top >= minY && top <= maxY;
  }
  isInSelectedLayer() {
    return this.analysis.selected;
  }
  calculatePercentageX(value) {
    return value / this.analysis.file.width * 100;
  }
  calculatePercentageY(value) {
    return value / this.analysis.file.height * 100;
  }
  /** @deprecated */
  getPercentageX() {
    return this.x / this.analysis.file.width * 100;
  }
  /** @deprecated */
  getPercentageY() {
    return this.y / this.analysis.file.height * 100;
  }
  getPercentageCoordinates() {
    const x = this.getPercentageX();
    const y = this.getPercentageY();
    return {
      x,
      y
    };
  }
  mouseEnter() {
    if (this.isHover === false) {
      this._isHover = true;
      this.actionOnMouseEnter();
      this.onMouseEnter.call(this);
    }
  }
  mouseLeave() {
    if (this.isHover === true) {
      this._isHover = false;
      this.actionOnMouseLeave();
      this.onMouseLeave.call(this);
    }
  }
  onMouseEnter = new CallbacksManager();
  onMouseLeave = new CallbacksManager();
  onActivate = new CallbacksManager();
  onDeactivate = new CallbacksManager();
  activate() {
    this._active = true;
    this.actionOnActivate();
  }
  deactivate() {
    this._active = false;
    this.actionOnDeactivate();
  }
};

// src/properties/analysis/analysis/internals/point/PointPoint.ts
var PointPoint = class _PointPoint extends AbstractPoint {
  static size = 20;
  static sizePx(aspect = 1) {
    return Math.round(_PointPoint.size * aspect).toString() + "px";
  }
  axisX;
  axisY;
  center;
  analyzeXFromTool(value) {
    return {
      x: value,
      placement: 2 /* MIDDLE */
    };
  }
  analyzeYFromTool(value) {
    return {
      y: value,
      placement: 2 /* MIDDLE */
    };
  }
  sideEffectOnXFromTool() {
    this.analysis.setLeft(this.x);
  }
  sideEffectOnYFromTool() {
    this.analysis.setTop(this.y);
  }
  constructor(key, top, left, analysis, color) {
    super(
      key,
      top,
      left,
      analysis,
      color,
      2 /* MIDDLE */,
      2 /* MIDDLE */
    );
    this.axisX = this.buildAxisX();
    this.axisY = this.buildAxisY();
    this.center = this.buildCenter();
    this.innerElement.appendChild(this.axisX);
    this.innerElement.appendChild(this.axisY);
    this.innerElement.appendChild(this.center);
    this.analysis.onValues.set(this.key, () => {
      const colorFromCurrentPalette = this.analysis.file.getColorAtPoint(this.x, this.y);
      if (this.center && colorFromCurrentPalette) {
        this.center.style.backgroundColor = colorFromCurrentPalette;
      }
    });
  }
  mayMoveToX(value) {
    return value <= this.file.width && value >= 0;
  }
  mayMoveToY(value) {
    return value <= this.file.height && value >= 0;
  }
  createInnerElement() {
    const element = document.createElement("div");
    element.classList.add("innerElement");
    element.style.position = "absolute";
    element.style.top = _PointPoint.sizePx(-0.5);
    element.style.left = _PointPoint.sizePx(-0.5);
    element.style.width = _PointPoint.sizePx();
    element.style.height = _PointPoint.sizePx();
    return element;
  }
  buildAxisX() {
    const axis = document.createElement("div");
    axis.style.position = "absolute";
    axis.style.width = "100%";
    axis.style.height = "1px";
    axis.style.left = "0px";
    axis.style.top = _PointPoint.sizePx(0.5);
    return axis;
  }
  buildAxisY() {
    const axis = document.createElement("div");
    axis.style.position = "absolute";
    axis.style.width = "1px";
    axis.style.height = "100%";
    axis.style.left = _PointPoint.sizePx(0.5);
    axis.style.top = "0px";
    return axis;
  }
  buildCenter() {
    const center = document.createElement("div");
    center.style.position = "absolute";
    center.style.top = `calc( ${_PointPoint.sizePx(0.5)} - 3px )`;
    center.style.left = `calc( ${_PointPoint.sizePx(0.5)} - 3px )`;
    ;
    center.style.width = "5px";
    center.style.height = "5px";
    center.style.borderStyle = "solid";
    center.style.borderWidth = "1px";
    const currentColor = this.analysis.file.getColorAtPoint(this.x, this.y);
    if (currentColor)
      center.style.backgroundColor = currentColor;
    return center;
  }
  onSetColor(value) {
    if (this.axisX) {
      this.axisX.style.backgroundColor = value;
    }
    if (this.axisY) {
      this.axisY.style.backgroundColor = value;
    }
    if (this.center) {
      this.center.style.borderColor = value;
    }
  }
  actionOnMouseEnter() {
    if (this.isInSelectedLayer()) {
      this.setColor(this.activeColor);
      this.setBoxShadow("white");
    }
  }
  actionOnMouseLeave() {
    if (this.isInSelectedLayer()) {
      this.setColor(this.analysis.initialColor);
    } else {
      this.setColor(this.inactiveColor);
    }
    this.setBoxShadow(void 0);
  }
  actionOnActivate() {
    if (this.innerElement) {
      this.setColor(this.activeColor);
    }
  }
  actionOnDeactivate() {
    if (this.innerElement) {
      this.setColor(this.inactiveColor);
    }
  }
  getRadius() {
    return 10;
  }
  setBoxShadow(color = void 0) {
    if (color === void 0) {
      this.axisX?.style.removeProperty("box-shadow");
      this.axisY?.style.removeProperty("box-shadow");
      this.center?.style.removeProperty("box-shadow");
    } else {
      const shadow = `0 0 5px 2px ${color}`;
      if (this.axisX) this.axisX.style.boxShadow = shadow;
      if (this.axisY) this.axisY.style.boxShadow = shadow;
      if (this.center) this.center.style.boxShadow = shadow;
    }
  }
};

// src/properties/analysis/analysis/internals/point/PointAnalysis.ts
var PointAnalysis = class _PointAnalysis extends AbstractAnalysis {
  getType() {
    return "point";
  }
  center;
  _graph;
  get graph() {
    if (!this._graph) {
      this._graph = new AnalysisGraph(this);
    }
    return this._graph;
  }
  static addAtPoint(key, color, file, top, left) {
    const item = new _PointAnalysis(
      key,
      color,
      file,
      top,
      left
    );
    return item;
  }
  constructor(key, color, file, top, left) {
    super(key, file, color);
    this._top = top;
    this._left = left;
    this._width = 0;
    this._height = 0;
    this.center = new PointPoint("center", top, left, this, color);
    this.points.set("center", this.center);
    this.recalculateValues();
  }
  setColorCallback(value) {
    this.center.setColor(value);
  }
  isWithin(x, y) {
    return this.center.isWithin(y, x);
  }
  getValues() {
    const value = this.file.getTemperatureAtPoint(this.center.x, this.center.y);
    return {
      min: value,
      max: value,
      avg: value
    };
  }
  async getAnalysisData() {
    return await this.file.reader.pointAnalysisData(this.center.x, this.center.y);
  }
  validateWidth() {
    return 0;
  }
  validateHeight() {
    return 0;
  }
  onSetLeft(validatedValue) {
    this.center.setXDirectly(validatedValue, 2 /* MIDDLE */);
    this.onSerializableChange.call(this, "left");
  }
  onSetTop(validatedValue) {
    this.center.setYDirectly(validatedValue, 2 /* MIDDLE */);
    this.onSerializableChange.call(this, "top");
  }
  onSetWidth() {
  }
  onSetHeight() {
  }
  getVerticalDimensionFromNewValue(value) {
    const val = Math.min(
      this.file.height - 1,
      Math.max(
        0,
        Math.round(value)
      )
    );
    return { top: val, bottom: val, height: 0 };
  }
  getHorizontalDimensionsFromNewValue(value) {
    const val = Math.min(
      this.file.width - 1,
      Math.max(
        0,
        Math.round(value)
      )
    );
    return { left: val, right: val, width: 0 };
  }
  recievedSerialized(input) {
    if (!this.serializedIsValid(input)) {
      return;
    }
    const splitted = input.split(";").map((segment) => segment.trim());
    let shouldRecalculate = false;
    const name = splitted[0];
    if (name !== this.name) {
      this.setName(name);
    }
    const graphOn = AbstractAnalysis.serializedSegmentsHasExact(splitted, "avg");
    if (graphOn !== this.graph.state.AVG) {
      this.graph.setAvgActivation(graphOn);
      shouldRecalculate = true;
    }
    const color = AbstractAnalysis.serializedGetStringValueByKey(splitted, "color");
    if (color === void 0) {
    } else if (color !== this.initialColor) {
      this.setInitialColor(color);
    }
    const top = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "top");
    const left = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "left");
    if (top !== void 0) {
      this.setTop(top);
      shouldRecalculate = true;
    }
    if (left !== void 0) {
      this.setLeft(left);
      shouldRecalculate = true;
    }
    if (shouldRecalculate) {
      this.recalculateValues();
    }
  }
  toSerialized() {
    const output = [];
    output.push(this.name);
    output.push("point");
    output.push(`top:${this.top}`);
    output.push(`left:${this.left}`);
    output.push(`color:${this.initialColor}`);
    if (this.graph.state.AVG) {
      output.push("avg");
    }
    return output.join(";");
  }
};

// src/properties/analysis/data/graphs/AnalysisGraph.ts
var AnalysisGraph = class {
  constructor(analysis) {
    this.analysis = analysis;
    this.hydrate();
  }
  _min = false;
  _max = false;
  _avg = false;
  get state() {
    return {
      "MIN": this._min,
      "MAX": this._max,
      "AVG": this._avg
    };
  }
  _value;
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = value;
    this.onGraphData.call(value, this.analysis);
  }
  setMinActivation(active) {
    if (this._min !== active) {
      this._min = active;
      this.emitGraphActivation();
      this.analysis.onSerializableChange.call(this.analysis, "min");
    }
  }
  setMaxActivation(active) {
    if (this._max !== active) {
      this._max = active;
      this.emitGraphActivation();
      this.analysis.onSerializableChange.call(this.analysis, "max");
    }
  }
  setAvgActivation(active) {
    if (this._avg !== active) {
      this._avg = active;
      this.emitGraphActivation();
      this.analysis.onSerializableChange.call(this.analysis, "avg");
    }
  }
  onGraphActivation = new CallbacksManager();
  onGraphData = new CallbacksManager();
  onAnalysisSelection = new CallbacksManager();
  emitGraphActivation() {
    this.onGraphActivation.call(
      this._min,
      this._max,
      this._avg
    );
  }
  async hydrate() {
    this.analysis.onSetInitialColor.set("__graphs", () => {
      this.analysis.file.analysisData.listeners.refreshOutput();
    });
    this.analysis.onSelected.set("__graphs", (analysis) => {
      this.onAnalysisSelection.call(true, analysis);
    });
    this.analysis.onMoveOrResize.set("__graphs", async (analysis) => {
      const data2 = await analysis.getAnalysisData();
      this.value = data2;
    });
    const data = await this.getGraphData();
    this.value = data;
  }
  async getGraphData() {
    const data = await this.analysis.getAnalysisData();
    return data;
  }
  getGraphColors() {
    if (this.analysis instanceof PointAnalysis) {
      if (this._avg) {
        return [this.analysis.initialColor];
      } else return [];
    }
    const output = [];
    Object.entries(this.state).forEach(([key, value]) => {
      key;
      if (value) {
        output.push(this.analysis.initialColor);
      }
    });
    return output;
  }
  getGraphLabels() {
    if (this.analysis instanceof PointAnalysis) {
      if (this._avg) {
        return [this.analysis.name];
      } else return [];
    }
    const output = [];
    Object.entries(this.state).forEach(([key, value]) => {
      if (value) {
        output.push(`${this.analysis.name} ${key}`);
      }
    });
    return output;
  }
  hasDataToPrint() {
    if (this.analysis instanceof PointAnalysis) {
      return this._avg;
    }
    return this._min || this._max || this._avg;
  }
  getDtaAtTime(timestamp) {
    if (this.analysis instanceof PointAnalysis) {
      if (this._avg) {
        const value2 = this.value;
        return [value2[timestamp]];
      } else return [];
    }
    const output = [];
    const value = this.value;
    if (this._min) {
      output.push(value[timestamp].min);
    }
    if (this._max) {
      output.push(value[timestamp].max);
    }
    if (this._avg) {
      output.push(value[timestamp].avg);
    }
    return output;
  }
};

// src/properties/analysis/analysis/internals/area/AbstractHandlePoint.ts
var AbstractHandlePoint = class extends AbstractPoint {
  constructor(key, top, left, analysis, color, placementX, placementY) {
    super(key, top, left, analysis, color, placementX, placementY);
  }
  createInnerElement() {
    const inner = document.createElement("div");
    inner.style.position = "absolute";
    inner.style.top = "-5px";
    inner.style.left = "-5px";
    inner.style.width = "10px";
    inner.style.height = "10px";
    inner.style.position = "absolute";
    inner.style.backgroundColor = this.color;
    return inner;
  }
  actionOnMouseEnter() {
    if (this.innerElement && this.isInSelectedLayer()) {
      this.innerElement.style.boxShadow = "0px 0px 10px 2px white";
      this.innerElement.style.borderWidth = "1px";
      this.innerElement.style.borderStyle = "solid";
      this.innerElement.style.borderColor = "white";
    }
  }
  actionOnMouseLeave() {
    if (this.innerElement) {
      this.innerElement.style.removeProperty("box-shadow");
      this.innerElement.style.removeProperty("border-width");
      this.innerElement.style.removeProperty("border-style");
      this.innerElement.style.removeProperty("border-color");
    }
  }
};

// src/properties/analysis/analysis/internals/area/CornerPoint.ts
var CornerPoint = class extends AbstractHandlePoint {
  _pairX;
  _pairY;
  get pairX() {
    return this._pairX;
  }
  get pairY() {
    return this._pairY;
  }
  setPairX(point) {
    this._pairX = point;
  }
  setPairY(point) {
    this._pairY = point;
  }
  getRadius() {
    return 10;
  }
  mayMoveToX(value) {
    return value <= this.file.width && value >= 0;
  }
  mayMoveToY(value) {
    return value <= this.file.height && value >= 0;
  }
  getCenterX() {
    return this.analysis.left + this.analysis.width / 2;
  }
  getCenterY() {
    return this.analysis.top + this.analysis.height / 2;
  }
  get isLeftSide() {
    return this.x <= this.getCenterX();
  }
  get isTopSide() {
    return this.y <= this.getCenterY();
  }
  get isRightSide() {
    return this.x > this.getCenterX();
  }
  get isBottomSide() {
    return this.y > this.getCenterY();
  }
  analyzeXFromTool(value) {
    const placement = this.isLeftSide ? 1 /* START */ : 3 /* END */;
    return {
      x: value,
      placement
    };
  }
  analyzeYFromTool(value) {
    const placement = this.isTopSide ? 1 /* START */ : 3 /* END */;
    return {
      y: value,
      placement
    };
  }
  sideEffectOnXFromTool(value, placement) {
    this.pairX.setXDirectly(value, placement);
    if (value > this.pairY.x) {
      this.analysis.leftSidePoints.forEach((p) => {
        p.setXDirectly(p.x, 1 /* START */);
      });
    } else {
      this.analysis.rightSidePoints.forEach((p) => {
        p.setXDirectly(p.x, 3 /* END */);
      });
    }
  }
  sideEffectOnYFromTool(value, placement) {
    this.pairY.setYDirectly(value, placement);
    if (value > this.pairX.y) {
      this.analysis.topSidePoints.forEach((p) => {
        p.setYDirectly(p.y, 1 /* START */);
      });
    } else {
      this.analysis.bottomSidePoints.forEach((p) => {
        p.setYDirectly(p.y, 3 /* END */);
      });
    }
  }
  isMoving = false;
  onSetColor(value) {
    if (this.innerElement)
      this.innerElement.style.backgroundColor = value;
  }
  actionOnActivate() {
    if (this.innerElement) {
      this.setColor(this.activeColor);
    }
  }
  actionOnDeactivate() {
    if (this.innerElement) {
      this.setColor(
        this.isInSelectedLayer() ? this.initialColor : this.inactiveColor
      );
    }
  }
};

// src/properties/analysis/analysis/internals/area/AbstractAreaAnalysis.ts
var AbstractAreaAnalysis = class extends AbstractAnalysis {
  wPx = (100 / this.file.width / 2).toString() + "%";
  hPx = (100 / this.file.height / 2).toString() + "%";
  tl;
  tr;
  bl;
  br;
  area;
  _graph;
  get graph() {
    if (!this._graph) {
      this._graph = new AnalysisGraph(this);
    }
    return this._graph;
  }
  isWithin(x, y) {
    return x >= this.left && x <= this.left + this.width && y >= this.top && y <= this.top + this.height;
  }
  static calculateDimensionsFromCorners(top, left, right, bottom) {
    const t = Math.min(top, bottom);
    const b = Math.max(top, bottom);
    const l = Math.min(left, right);
    const r = Math.max(left, right);
    const w = r - l;
    const h = b - t;
    return {
      top: t,
      left: l,
      width: w,
      height: h
    };
  }
  constructor(key, color, file, top, left, width, height) {
    super(key, file, color);
    let right = left;
    let bottom = top;
    if (width !== void 0 && height !== void 0) {
      right = left + width;
      bottom = top + height;
    }
    this.area = this.buildArea(top, left, width, height);
    this.tl = this.addPoint(
      "tl",
      top,
      left,
      1 /* START */,
      1 /* START */
    );
    this.tr = this.addPoint(
      "tr",
      top,
      right,
      3 /* END */,
      1 /* START */
    );
    this.bl = this.addPoint(
      "bl",
      bottom,
      left,
      1 /* START */,
      3 /* END */
    );
    this.br = this.addPoint(
      "br",
      bottom,
      right,
      3 /* END */,
      3 /* END */
    );
    this.tl.setPairX(this.bl);
    this.tl.setPairY(this.tr);
    this.tr.setPairX(this.br);
    this.tr.setPairY(this.tl);
    this.bl.setPairX(this.tl);
    this.bl.setPairY(this.br);
    this.br.setPairX(this.tr);
    this.br.setPairY(this.bl);
    this.calculateBounds();
    this.onMoveOrResize.set("sync the area", () => {
      this.calculateBounds();
    });
  }
  setColorCallback(value) {
    this.points.forEach((point) => point.setColor(value));
    this.area.setColor(value);
  }
  calculateBounds() {
    let leftMost = this.file.width;
    let rightMost = 0;
    let topMost = this.file.height;
    let bottomMost = 0;
    this.points.forEach((point) => {
      if (point.x > rightMost) {
        rightMost = point.x;
      }
      if (point.x < leftMost) {
        leftMost = point.x;
      }
      if (point.y < topMost) {
        topMost = point.y;
      }
      if (point.y > bottomMost) {
        bottomMost = point.y;
      }
    });
    this._left = leftMost;
    this._top = topMost;
    this._width = rightMost - leftMost;
    this._height = bottomMost - topMost;
    this.area.left = this.left;
    this.area.top = this.top;
    this.area.height = this.height;
    this.area.width = this.width;
  }
  addPoint(role, top, left, placementX, placementY) {
    const point = new CornerPoint(role, top, left, this, this.color, placementX, placementY);
    this.points.set(role, point);
    return point;
  }
  validateWidth(value) {
    const max = this.file.width - 1 - this.left;
    return Math.max(0, Math.min(max, Math.round(value)));
  }
  validateHeight(value) {
    const max = this.file.height - 1 - this.top;
    return Math.max(0, Math.min(max, Math.round(value)));
  }
  onSetLeft(validatedValue) {
    this.area.left = validatedValue;
    this.forPoints(this.leftSidePoints, (point) => {
      point.setXDirectly(validatedValue, 1 /* START */);
    });
    this.forPoints(this.rightSidePoints, (point) => {
      point.setXDirectly(this.right, 3 /* END */);
    });
  }
  onSetTop(validatedValue) {
    this.area.top = validatedValue;
    this.forPoints(this.topSidePoints, (point) => {
      point.setYDirectly(validatedValue, 1 /* START */);
    });
    this.forPoints(this.bottomSidePoints, (point) => {
      point.setYDirectly(this.bottom, 3 /* END */);
    });
  }
  onSetWidth(validatedValue) {
    this.area.width = validatedValue;
    this.forPoints(this.leftSidePoints, (point) => {
      point.setXDirectly(this.left, 1 /* START */);
    });
    this.forPoints(this.rightSidePoints, (point) => {
      point.setXDirectly(this.right, 3 /* END */);
    });
  }
  onSetHeight(validatedValue) {
    this.area.height = validatedValue;
    this.forPoints(this.topSidePoints, (point) => {
      point.setYDirectly(this.top, 1 /* START */);
    });
    this.forPoints(this.bottomSidePoints, (point) => {
      point.setYDirectly(this.bottom, 3 /* END */);
    });
  }
  getVerticalDimensionFromNewValue(value, preferredSide) {
    const val = Math.round(value);
    const maxW = this.file.height - 1;
    const theOtherSide = preferredSide === "top" ? this.bottom : this.top;
    if (val <= 0) {
      return {
        top: 0,
        bottom: theOtherSide,
        height: theOtherSide
      };
    } else if (val > maxW) {
      return {
        top: theOtherSide,
        bottom: maxW,
        height: maxW - theOtherSide
      };
    } else if (preferredSide === "bottom") {
      if (val <= this.top) {
        return {
          top: val,
          bottom: this.top,
          height: this.top - val
        };
      } else {
        return {
          top: this.top,
          bottom: val,
          height: val - this.top
        };
      }
    } else {
      if (val >= this.bottom) {
        return {
          top: this.bottom,
          bottom: val,
          height: val - this.bottom
        };
      } else {
        return {
          top: val,
          bottom: this.bottom,
          height: this.bottom - val
        };
      }
    }
  }
  getHorizontalDimensionsFromNewValue(value, preferredSide) {
    const val = Math.round(value);
    const maxW = this.file.width - 1;
    const theOtherSide = preferredSide === "left" ? this.right : this.left;
    if (val <= 0) {
      return {
        left: 0,
        right: theOtherSide,
        width: theOtherSide
      };
    } else if (val > maxW) {
      return {
        left: theOtherSide,
        right: maxW,
        width: maxW - theOtherSide
      };
    } else if (preferredSide === "right") {
      if (val <= this.left) {
        return {
          left: val,
          right: this.left,
          width: this.left - val
        };
      } else {
        return {
          left: this.left,
          right: val,
          width: val - this.left
        };
      }
    } else {
      if (val >= this.right) {
        return {
          left: this.right,
          right: val,
          width: val - this.right
        };
      } else {
        return {
          left: val,
          right: this.right,
          width: this.right - val
        };
      }
    }
  }
  get leftSidePoints() {
    return Array.from(this.points.values()).filter((point) => point.isLeftSide);
  }
  get rightSidePoints() {
    return Array.from(this.points.values()).filter((point) => point.isRightSide);
  }
  get topSidePoints() {
    return Array.from(this.points.values()).filter((point) => point.isTopSide);
  }
  get bottomSidePoints() {
    return Array.from(this.points.values()).filter((point) => point.isBottomSide);
  }
  forPoints(points, fn) {
    points.forEach((point) => fn(point));
  }
  recievedSerialized(input) {
    if (!this.serializedIsValid(input)) {
      return;
    }
    const splitted = input.split(";").map((segment) => segment.trim());
    let shouldRecalculate = false;
    const name = splitted[0];
    if (name !== this.name) {
      this.setName(name);
    }
    const avgOn = AbstractAnalysis.serializedSegmentsHasExact(splitted, "avg");
    if (avgOn !== this.graph.state.AVG) {
      this.graph.setAvgActivation(avgOn);
    }
    const minOn = AbstractAnalysis.serializedSegmentsHasExact(splitted, "min");
    if (minOn !== this.graph.state.MIN) {
      this.graph.setMinActivation(minOn);
    }
    const maxOn = AbstractAnalysis.serializedSegmentsHasExact(splitted, "max");
    if (maxOn !== this.graph.state.MAX) {
      this.graph.setMaxActivation(maxOn);
    }
    const color = AbstractAnalysis.serializedGetStringValueByKey(splitted, "color");
    if (color === void 0) {
    } else if (color !== this.initialColor) {
      this.setInitialColor(color);
    }
    const top = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "top");
    const left = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "left");
    const width = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "width");
    const height = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "height");
    if (top !== void 0 && top !== this.top) {
      this.setTop(top);
      shouldRecalculate = true;
    }
    if (left !== void 0 && left !== this.left) {
      this.setLeft(left);
      shouldRecalculate = true;
    }
    if (width !== void 0 && width !== this.width) {
      this.setWidth(width);
      shouldRecalculate = true;
    }
    if (height !== void 0 && height !== this.height) {
      this.setHeight(height);
      shouldRecalculate = true;
    }
    if (shouldRecalculate) {
      this.recalculateValues();
    }
  }
  toSerialized() {
    const output = [];
    output.push(this.name);
    output.push(this.getType());
    output.push(`color:${this.initialColor}`);
    output.push(`top:${this.top}`);
    output.push(`left:${this.left}`);
    output.push(`width:${this.width}`);
    output.push(`height:${this.height}`);
    if (this.graph.state.AVG) output.push("avg");
    if (this.graph.state.MIN) output.push("min");
    if (this.graph.state.MAX) output.push("max");
    return output.join(";");
  }
};

// src/properties/analysis/analysis/internals/area/AbstractArea.ts
var AbstractArea = class {
  constructor(analysis, top, right, left, bottom) {
    this.analysis = analysis;
    this.pxX = 100 / this.analysis.file.width;
    this.pxY = 100 / this.analysis.file.height;
    this.build();
    this.top = top;
    this.left = left;
    this.width = right;
    this.height = bottom;
  }
  pxX;
  pxY;
  get fileWidth() {
    return this.analysis.file.width;
  }
  get fileHeight() {
    return this.analysis.file.height;
  }
  get root() {
    return this.analysis.layerRoot;
  }
  element;
  _top;
  _width;
  _left;
  _height;
  get top() {
    return this._top;
  }
  set top(value) {
    this._top = value;
    if (this.element) {
      this.element.style.top = `${this._top / this.fileHeight * 100}%`;
    }
  }
  get left() {
    return this._left;
  }
  set left(value) {
    this._left = value;
    if (this.element) {
      this.element.style.left = `${this._left / this.fileWidth * 100}%`;
    }
  }
  get height() {
    return this._height;
  }
  set height(value) {
    this._height = value;
    if (this.element) {
      this.element.style.height = `calc( ${this.height / this.fileHeight * 100}% + ${this.pxY}% )`;
    }
  }
  get width() {
    return this._width;
  }
  set width(value) {
    this._width = value;
    if (this.element) {
      this.element.style.width = `calc( ${this.width / this.fileWidth * 100}% + ${this.pxX}% )`;
    }
  }
  get center() {
    return {
      x: this.left + this.width / 2,
      y: this.top + this.height / 2
    };
  }
  build() {
    this.element = document.createElement("div");
    this.element.style.position = "absolute";
    this.onBuild();
    this.root.appendChild(this.element);
  }
  setColor(value) {
    this.onSetColor(value);
  }
};

// src/properties/analysis/analysis/internals/area/ellipsis/EllipsisArea.ts
var EllipsisArea = class extends AbstractArea {
  onBuild() {
    this.element.style.borderWidth = "1px";
    this.element.style.borderColor = this.analysis.color;
    this.element.style.borderStyle = "solid";
    this.element.style.borderRadius = "50%";
  }
  onSetColor(value) {
    this.element.style.borderColor = value;
  }
};

// src/properties/analysis/analysis/internals/area/ellipsis/EllipsisAnalysis.ts
var EllipsisAnalysis = class _EllipsisAnalysis extends AbstractAreaAnalysis {
  getType() {
    return "ellipsis";
  }
  static startAddingAtPoint(key, color, file, top, left) {
    const item = new _EllipsisAnalysis(
      key,
      color,
      file,
      top,
      left
    );
    item.br.activate();
    return item;
  }
  static build(key, color, file, _top, _left, _right, _bottom) {
    const { top, left, width, height } = _EllipsisAnalysis.calculateDimensionsFromCorners(_top, _left, _right, _bottom);
    const item = new _EllipsisAnalysis(
      key,
      color,
      file,
      top,
      left,
      width,
      height
    );
    item.recalculateValues();
    return item;
  }
  buildArea(x, y, width, height) {
    if (width !== void 0 && height !== void 0) {
      return new EllipsisArea(
        this,
        x,
        y,
        x + width,
        y + height
      );
    }
    return new EllipsisArea(this, x, y, x, y);
  }
  getValues() {
    const fromX = this.left;
    const toX = this.left + this.width;
    const fromY = this.top;
    const toY = this.top + this.height;
    let min = Infinity;
    let max = -Infinity;
    let count = 0;
    let sum = 0;
    for (let y = fromY; y < toY; y++) {
      const rowOffset = this.file.width * y;
      for (let x = fromX; x <= toX; x++) {
        if (this.isWithin(x, y)) {
          const point = this.file.pixels[rowOffset + x];
          if (point < min) {
            min = point;
          }
          if (point > max) {
            max = point;
          }
          sum += point;
          count++;
        }
      }
    }
    return {
      min,
      max,
      avg: sum / count
    };
  }
  isWithin(x, y) {
    const centerX = this.left + this.width / 2;
    const centerY = this.top + this.height / 2;
    const normalizedX = (x - centerX) / (this.width / 2);
    const normalizedY = (y - centerY) / (this.height / 2);
    return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
  }
  async getAnalysisData() {
    return await this.file.reader.ellipsisAnalysisData(
      this.left,
      this.top,
      this.width,
      this.height
    );
  }
};

// src/properties/analysis/analysis/internals/area/rectangle/RectangleArea.ts
var RectangleArea = class extends AbstractArea {
  onBuild() {
    this.element.style.borderWidth = "1px";
    this.element.style.borderColor = this.analysis.color;
    this.element.style.borderStyle = "solid";
  }
  onSetColor(value) {
    this.element.style.borderColor = value;
  }
};

// src/properties/analysis/analysis/internals/area/rectangle/RectangleAnalysis.ts
var RectangleAnalysis = class _RectangleAnalysis extends AbstractAreaAnalysis {
  getType() {
    return "rectangle";
  }
  static startAddingAtPoint(key, color, file, top, left) {
    const item = new _RectangleAnalysis(
      key,
      color,
      file,
      top,
      left
    );
    item.br.activate();
    return item;
  }
  static build(key, color, file, _top, _left, _right, _bottom) {
    const { top, left, width, height } = _RectangleAnalysis.calculateDimensionsFromCorners(_top, _left, _right, _bottom);
    const item = new _RectangleAnalysis(
      key,
      color,
      file,
      top,
      left,
      width,
      height
    );
    item.recalculateValues();
    return item;
  }
  buildArea(x, y, width, height) {
    if (width !== void 0 && height !== void 0) {
      return new RectangleArea(
        this,
        x,
        y,
        x + width,
        y + height
      );
    }
    return new RectangleArea(this, x, y, x, y);
  }
  getValues() {
    const fromX = this.left;
    const toX = this.left + this.width;
    const fromY = this.top;
    const toY = this.top + this.height;
    let min = Infinity;
    let max = -Infinity;
    let count = 0;
    let sum = 0;
    for (let y = fromY; y < toY; y++) {
      const rowOffset = this.file.width * y;
      for (let x = fromX; x <= toX; x++) {
        const point = this.file.pixels[rowOffset + x];
        if (point < min) {
          min = point;
        }
        if (point > max) {
          max = point;
        }
        sum += point;
        count++;
      }
    }
    return {
      min,
      max,
      avg: sum / count
    };
  }
  async getAnalysisData() {
    return await this.file.reader.rectAnalysisData(
      this.left,
      this.top,
      this.width,
      this.height
    );
  }
};

// src/properties/analysis/analysis/storage/AnalysisLayersStorage.ts
var availableAnalysisColors = [
  "Blue",
  "Red",
  "Lightblue",
  "Green",
  "Brown",
  "Yellow",
  "Navy",
  "Pink",
  "DarkGoldenRod",
  "GreenYellow",
  "SpringGreen",
  "SkyBlue"
];
var AnalysisLayersStorage = class extends Map {
  constructor(drive) {
    super();
    this.drive = drive;
  }
  /** Array of all layers ordered from oldest to the newest */
  layers = [];
  get slots() {
    return this.drive.parent.slots;
  }
  /** Fired whenever an analysis is added */
  onAdd = new CallbacksManager();
  /** Fired whenever an analysis is removed */
  onRemove = new CallbacksManager();
  /** Fired whenever the selection list changes */
  onSelectionChange = new CallbacksManager();
  /** Array of available colors */
  colors = availableAnalysisColors;
  // Adding analysis
  addAnalysis(analysis, slotNumber) {
    if (this.has(analysis.key)) {
      this.removeAnalysis(analysis.key);
    }
    analysis.setColor(analysis.initialColor);
    this.set(analysis.key, analysis);
    this.layers = [...this.layers, analysis];
    const slotNum = slotNumber === true ? this.slots.getNextFreeSlotNumber() : slotNumber === false ? void 0 : slotNumber;
    if (slotNum !== void 0) {
      this.slots.assignSlot(slotNum, analysis);
    }
    this.onAdd.call(analysis, this.all);
    this.drive.dangerouslySetValueFromStorage(this.all);
    return this;
  }
  removeAnalysis(key) {
    if (this.has(key)) {
      const analysis = this.get(key);
      if (analysis) {
        this.slots.unassignAnalysisFromItsSlot(analysis);
        analysis.remove();
        this.delete(key);
        this.layers = this.layers.filter((analysis2) => analysis2.key !== key);
        this.drive.dangerouslySetValueFromStorage(this.all);
        this.onRemove.call(key);
      }
    }
  }
  /** Add a rectangular analysis in the given position and start editing it. */
  createRectFrom(top, left) {
    const newAnalysis = RectangleAnalysis.startAddingAtPoint(
      this.getNextName("Rectangle"),
      this.getNextColor(),
      this.drive.parent,
      top,
      left
    );
    this.addAnalysis(newAnalysis, false);
    return newAnalysis;
  }
  /** Build an ellyptical analysis at the given position. */
  placeRectAt(name, top, left, right, bottom, color, slotNumber) {
    const newAnalysis = RectangleAnalysis.build(
      name,
      color ?? this.getNextColor(),
      this.drive.parent,
      top,
      left,
      right,
      bottom
    );
    newAnalysis.ready = true;
    this.addAnalysis(newAnalysis, slotNumber);
    return newAnalysis;
  }
  /** Add an ellyptical analysis in the given position and start editing it */
  createEllipsisFrom(top, left) {
    const newAnalysis = EllipsisAnalysis.startAddingAtPoint(
      this.getNextName("Ellipsis"),
      this.getNextColor(),
      this.drive.parent,
      top,
      left
    );
    this.addAnalysis(newAnalysis, false);
    return newAnalysis;
  }
  /** Build an ellyptical analysis at the given position. */
  placeEllipsisAt(name, top, left, right, bottom, color, slotNumber) {
    const newAnalysis = EllipsisAnalysis.build(
      name,
      color ?? this.getNextColor(),
      this.drive.parent,
      top,
      left,
      right,
      bottom
    );
    newAnalysis.ready = true;
    this.addAnalysis(newAnalysis, slotNumber);
    return newAnalysis;
  }
  createPointAt(top, left) {
    const newAnalysis = PointAnalysis.addAtPoint(
      this.getNextName("Point"),
      this.getNextColor(),
      this.drive.parent,
      top,
      left
    );
    this.addAnalysis(newAnalysis, true);
    return newAnalysis;
  }
  placePointAt(name, top, left, color, slotNumber) {
    const newAnalysis = PointAnalysis.addAtPoint(
      name,
      color ?? this.getNextColor(),
      this.drive.parent,
      top,
      left
    );
    newAnalysis.ready = true;
    this.addAnalysis(newAnalysis, slotNumber);
    return newAnalysis;
  }
  selectAll() {
    this.all.filter((analysis) => {
      if (analysis.selected === false) {
        analysis.setSelected(false, false);
      }
    });
    this.onSelectionChange.call(this.selectedOnly);
  }
  deselectAll() {
    this.selectedOnly.forEach((analysis) => {
      analysis.setDeselected(false);
    });
    this.onSelectionChange.call(this.selectedOnly);
  }
  /** Accessors */
  /** Array of all analysis ordered from the oldest to the newest. */
  get all() {
    return this.layers;
  }
  /** Array of all active analysis ordered from the oldest to the newest. */
  get selectedOnly() {
    return this.all.filter((analysis) => analysis.selected === true);
  }
  /** Get color for the next analysis */
  getNextColor() {
    const usedColors = this.all.map((analysis) => analysis.initialColor);
    const availableColors = availableAnalysisColors.filter((color) => !usedColors.includes(color));
    if (availableColors.length > 0) {
      return availableColors[0];
    } else {
      return availableAnalysisColors[0];
    }
  }
  /** Get name for the next analysis */
  getNextName(type) {
    return `${type} ${this.all.length}`;
  }
};

// src/properties/analysis/analysis/storage/AnalysisPointsAccessor.ts
var AnalysisPointsAccessor = class {
  constructor(drive) {
    this.drive = drive;
  }
  /** Get all points from all layers */
  get all() {
    return this.extractPointsFromLayers(this.drive.layers.all);
  }
  /** Get all points from selected layers */
  get allInSelectedLayers() {
    return this.extractPointsFromLayers(this.drive.layers.selectedOnly);
  }
  /** Get only active points from selected layers */
  get activeInSelectedLayers() {
    return this.extractPointsFromLayers(this.drive.layers.selectedOnly, true);
  }
  /** Extract points from all provided layers */
  extractPointsFromLayers(layers, activeOnly = false) {
    return layers.reduce((state, current) => {
      const currentPoints = activeOnly ? current.arrayOfActivePoints : current.arrayOfPoints;
      return [...state, ...currentPoints];
    }, []);
  }
};

// src/properties/analysis/analysis/AnalysisDrive.ts
var AnalysisDrive = class extends AbstractProperty {
  layers = new AnalysisLayersStorage(this);
  points = new AnalysisPointsAccessor(this);
  listener;
  /** Alias of the current `ToolDrive` value. */
  get currentTool() {
    return this.parent.group.tool.value;
  }
  /** Cached listener on `this.listenerLayerContainer` - pointermove event. */
  bindedPointerMoveListener;
  /** Cached listener on `this.listenerLayerContainer` - pointerdown event. */
  bindedPointerDownListener;
  /** Cached listener on `this.listenerLayerContainer` - pointerup event. */
  bindedPointerUpListener;
  /** 
   * Value of this drive is stored in `AnalysisLayersStorage` and from there, it is mirrored to the drive.
   * It is better to add listeners to the storage, not to the drive.
   */
  dangerouslySetValueFromStorage(value) {
    this.value = value;
  }
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  /** Calculate the top/left position from a `MouseEvent` */
  getRelativePosition(event) {
    if (!this.listener) {
      return {
        top: 0,
        left: 0
      };
    }
    const absoluteWidth = this.listener.clientWidth;
    const fileWidth = this.parent.width;
    const layerX = event.layerX;
    const xAspect = layerX / absoluteWidth;
    const x = Math.round(fileWidth * xAspect);
    const absoluteHeight = this.listener.clientHeight;
    const fileHeight = this.parent.height;
    const layerY = event.layerY;
    const yAspect = layerY / absoluteHeight;
    const y = Math.round(fileHeight * yAspect);
    return {
      top: y,
      left: x
    };
  }
  /** Activate listeners for the current drive on the file's listener layer. */
  activateListeners(container) {
    this.listener = container;
    this.bindedPointerMoveListener = (event) => {
      const position = this.getRelativePosition(event);
      this.points.all.forEach((point) => {
        if (point.active) {
          this.currentTool.onPointMove(point, position.top, position.left);
        }
        const pointIsUnderCursor = point.isWithin(position.top, position.left);
        if (pointIsUnderCursor) {
          this.currentTool.onPointEnter(point);
        } else if (!pointIsUnderCursor) {
          this.currentTool.onPointLeave(point);
        }
      });
    };
    this.bindedPointerDownListener = (event) => {
      const position = this.getRelativePosition(event);
      this.currentTool.onCanvasClick(position.top, position.left, this.parent);
      this.points.all.forEach((point) => {
        if (point.isWithin(position.top, position.left)) {
          this.currentTool.onPointDown(point);
        }
      });
    };
    this.bindedPointerUpListener = () => {
      this.points.all.forEach((point) => {
        this.currentTool.onPointUp(point);
      });
    };
    this.listener.addEventListener("pointermove", this.bindedPointerMoveListener);
    this.listener.addEventListener("pointerdown", this.bindedPointerDownListener);
    this.listener.addEventListener("pointerup", this.bindedPointerUpListener);
  }
  /** Remove all listeners from the file's listener layer */
  deactivateListeners() {
    if (this.bindedPointerMoveListener && this.listener) {
      this.listener.removeEventListener("pointermove", this.bindedPointerMoveListener);
    }
    if (this.bindedPointerDownListener && this.listener) {
      this.listener.removeEventListener("pointerdown", this.bindedPointerDownListener);
    }
    if (this.bindedPointerUpListener && this.listener) {
      this.listener.removeEventListener("pointerup", this.bindedPointerUpListener);
    }
  }
};

// src/properties/analysis/data/AnalysisDataState.ts
import { download, generateCsv, mkConfig } from "export-to-csv";

// src/properties/analysis/data/graphs/AnalysisGraphsStorage.ts
import { format as format2 } from "date-fns";
var AnalysisGraphsStorage = class {
  constructor(drive) {
    this.drive = drive;
    this.layers.onAdd.set(this.listenerKey, async (layer) => {
      const item = layer.graph;
      this.addGraph(item);
      item.onAnalysisSelection.set(this.listenerKey, async () => {
        this.refreshOutput();
      });
      item.onGraphActivation.set(this.listenerKey, async () => {
        this.refreshOutput();
      });
      item.onGraphData.set(this.listenerKey, async () => {
        this.refreshOutput();
      });
      item.analysis.onSetName.set(this.listenerKey, () => {
        this.refreshOutput();
      });
    });
    this.layers.onRemove.set(this.listenerKey, async (layer) => {
      this.removeGraph(layer);
      this.refreshOutput();
    });
  }
  listenerKey = "___listen-to-graphs___";
  get layers() {
    return this.drive.parent.analysis.layers;
  }
  _graphs = /* @__PURE__ */ new Map();
  get graphs() {
    return this._graphs;
  }
  addGraph(graph) {
    this._graphs.set(graph.analysis.key, graph);
    this.onAddGraph.call(graph);
  }
  removeGraph(graph) {
    this._graphs.delete(graph);
    this.onRemoveGraph.call(graph);
  }
  _output = {
    values: [[]],
    colors: []
  };
  get output() {
    return this._output;
  }
  set output(output) {
    this._output = output;
    this.onOutput.call(output);
  }
  onOutput = new CallbacksManager();
  onAddGraph = new CallbacksManager();
  onRemoveGraph = new CallbacksManager();
  refreshOutput() {
    const output = {
      values: [["Time"]],
      colors: []
    };
    this.graphs.forEach((graph) => {
      output.values[0].push(...graph.getGraphLabels());
      output.colors.push(...graph.getGraphColors());
    });
    this.graphs.forEach((graph) => {
      if (graph.hasDataToPrint()) {
        if (graph.value) {
          Object.keys(graph.value).forEach((key, index) => {
            let row = output.values[index + 1];
            if (row === void 0) {
              const date = /* @__PURE__ */ new Date();
              date.setTime(parseInt(key));
              row = [date];
              output.values[index + 1] = row;
            }
            const array = row;
            array.push(...graph.getDtaAtTime(parseInt(key)));
          });
        }
      }
    });
    this.output = output;
    return output;
  }
  hasGraph() {
    return Object.values(this.graphs).find((graph) => graph.hasDataToPrint()).length > 0;
  }
  generateExportData() {
    const dataBuffer = {};
    const header = [
      {
        key: "time_relative",
        displayLabel: "Relative Time"
      },
      {
        key: "time_absolute",
        displayLabel: "Absolute Time"
      },
      {
        key: "millisecondy",
        displayLabel: "Milliseconds"
      },
      {
        key: "timestamp",
        displayLabel: "Timestamp"
      }
    ];
    for (const graph of this.graphs.values()) {
      const labels = graph.getGraphLabels();
      for (const label of labels) {
        header.push({
          key: label,
          displayLabel: `${label} (${graph.analysis.initialColor}, ${graph.analysis.width} x ${graph.analysis.height} px)`
        });
      }
      if (graph.value) {
        Object.keys(graph.value).forEach((key) => {
          if (!Object.keys(dataBuffer).includes(key)) {
            const timestamp_relative = parseInt(key);
            const timestamp_absolute = timestamp_relative + graph.analysis.file.timestamp;
            dataBuffer[key] = {
              [header[0].key]: format2(timestamp_relative, "m:ss:SSS") + " ",
              [header[1].key]: format2(timestamp_absolute, "d. M.y m:ss:SSS") + " ",
              [header[2].key]: timestamp_relative,
              [header[3].key]: timestamp_absolute
            };
          }
          const values = graph.getDtaAtTime(parseInt(key));
          labels.forEach((label, index) => {
            dataBuffer[key][label] = values[index];
          });
        });
      }
    }
    return {
      header,
      data: Object.values(dataBuffer)
    };
  }
};

// src/properties/analysis/data/AnalysisDataState.ts
var AnalysisDataState = class extends AbstractProperty {
  _hasActiveGraphs = false;
  get hasActiveGraphs() {
    return this._hasActiveGraphs;
  }
  onGraphsPresence = new CallbacksManager();
  listeners = new AnalysisGraphsStorage(this);
  constructor(parent) {
    super(parent, { values: [[]], colors: [] });
    this.listeners.onOutput.set("__mirror_output_to_local_state", async (output) => {
      this.value = output;
      if (output.colors.length > 0) {
        if (!this.hasActiveGraphs) {
          this._hasActiveGraphs = true;
          this.onGraphsPresence.call(true);
        }
      } else {
        if (this.hasActiveGraphs) {
          this._hasActiveGraphs = false;
          this.onGraphsPresence.call(false);
        }
      }
    });
  }
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  dangerouslyUpdateValue(value) {
    this.value = value;
  }
  /** Assamble the current analysis data and download them as CSV directly. */
  downloadData() {
    const { data, header } = this.listeners.generateExportData();
    const csvConfig = mkConfig({
      fieldSeparator: ";",
      filename: `analysis_${this.parent.fileName}_${Date.now()}.csv`,
      columnHeaders: header
    });
    const csv = generateCsv(csvConfig)(data);
    download(csvConfig)(csv);
  }
};

// src/properties/analysis/slots/AnalysisSlot.ts
var AnalysisSlot = class {
  constructor(slot, analysis) {
    this.slot = slot;
    this._analysis = analysis;
    this.hydrate(analysis);
    this._serialized = this.analysis.toSerialized();
    this.propagateSerialisationUp(this._serialized);
  }
  _analysis;
  get analysis() {
    return this._analysis;
  }
  _serialized;
  get serialized() {
    return this._serialized;
  }
  /** @deprecated Serialisation is emitted by the driver. This emitter is used mainly in tests, but not elsewhere. */
  onSerialize = new CallbacksManager();
  /** Serialisation is done in the next tick */
  enqueuedSerialisation;
  /** Generate the listener key for this slot */
  listenerKey(operation) {
    return `slot ${this.slot} ${operation}`;
  }
  /** Remove all listeners created by this slot */
  dehydrate(analysis) {
    analysis.onSerializableChange.delete(this.listenerKey("serializable change"));
  }
  /** Add all listeners to the analysis object */
  hydrate(analysis) {
    analysis.onSerializableChange.set(this.listenerKey("serializable change"), () => {
      this.enqueueSerialisation();
    });
  }
  enqueueSerialisation() {
    if (!this.enqueuedSerialisation) {
      this.enqueuedSerialisation = setTimeout(() => {
        this.serialize();
        this.enqueuedSerialisation = void 0;
      }, 0);
    }
  }
  serialize() {
    this._serialized = this.analysis.toSerialized();
    this.onSerialize.call(this._serialized, this.analysis);
    this.propagateSerialisationUp(this._serialized);
  }
  recieveSerialized(serialized) {
    this.analysis.recievedSerialized(serialized);
    const newSerialized = this.analysis.toSerialized();
    if (newSerialized !== serialized) {
      this._serialized = newSerialized;
      this.onSerialize.call(this._serialized, this.analysis);
    }
  }
  /** Call global and particular callbacks */
  propagateSerialisationUp(value) {
    const manager = this.analysis.file.slots.getOnSerializeManager(this.slot);
    if (manager) {
      manager.call(value);
    }
  }
};

// src/properties/analysis/slots/AnalysisSlotsDrive.ts
var AnalysisSlotsState = class _AnalysisSlotsState extends AbstractProperty {
  static MAX_SLOTS = 7;
  /** @deprecated Use particular assignement slot instead */
  onSlotInit = new CallbacksManager();
  /** @deprecated Use particular assignement slot instead */
  onSlotRemove = new CallbacksManager();
  onSlot1Assignement = new CallbacksManager();
  onSlot2Assignement = new CallbacksManager();
  onSlot3Assignement = new CallbacksManager();
  onSlot4Assignement = new CallbacksManager();
  onSlot5Assignement = new CallbacksManager();
  onSlot6Assignement = new CallbacksManager();
  onSlot7Assignement = new CallbacksManager();
  onSlot1Serialize = new CallbacksManager();
  onSlot2Serialize = new CallbacksManager();
  onSlot3Serialize = new CallbacksManager();
  onSlot4Serialize = new CallbacksManager();
  onSlot5Serialize = new CallbacksManager();
  onSlot6Serialize = new CallbacksManager();
  onSlot7Serialize = new CallbacksManager();
  /** Calculate the next free slot */
  getNextFreeSlotNumber() {
    for (let i = 1; i <= _AnalysisSlotsState.MAX_SLOTS; i++) {
      if (!this.hasSlot(i)) return i;
    }
  }
  assignSlot(slot, analysis) {
    const existingSlot = this.getSlot(slot);
    if (existingSlot !== void 0) {
      this.removeSlotAndAnalysis(slot);
    }
    const analysisSlot = this.getAnalysisSlot(analysis);
    if (analysisSlot !== void 0) {
      this.unassignAnalysisFromItsSlot(this.getSlot(analysisSlot).analysis);
    }
    const value = new AnalysisSlot(slot, analysis);
    this.value.set(slot, value);
    const assignementManager = this.getOnAssignementManager(slot);
    const serialisationManager = this.getOnSerializeManager(slot);
    if (assignementManager) assignementManager.call(value);
    if (serialisationManager) serialisationManager.call(value.serialized);
    this.onSlotInit.call(slot, value);
    this.callEffectsAndListeners();
    return value;
  }
  hasSlot(slot) {
    return this.value.has(slot);
  }
  getSlot(slot) {
    return this.value.get(slot);
  }
  getSlotMap() {
    const map = /* @__PURE__ */ new Map();
    [1, 2, 3, 4, 5, 6, 7].forEach((number) => {
      if (this.hasSlot(number)) {
        map.set(number, this.getSlot(number));
      } else {
        map.set(number, void 0);
      }
    });
    return map;
  }
  getAnalysisSlot(analysis) {
    for (const a of this.value.values()) {
      if (a.analysis.key === analysis.key) {
        return a.slot;
      }
    }
  }
  /**
   * Completely remove the slot and also the corresponding analysis
   */
  removeSlotAndAnalysis(slot) {
    const value = this.value.get(slot);
    if (value) {
      const analysis = value.analysis;
      this.emitOnAssignement(slot, void 0);
      this.value.delete(slot);
      this.parent.analysis.layers.removeAnalysis(analysis.key);
      this.callEffectsAndListeners();
    }
  }
  /**
   * Remove a slot that is assigned to a given analysis, but keep the analysis 
   */
  unassignAnalysisFromItsSlot(analysis) {
    for (const a of this.value.values()) {
      if (a.analysis.key === analysis.key) {
        this.emitOnAssignement(a.slot, void 0);
        this.value.delete(a.slot);
        this.parent.group.analysisSync.deleteSlot(this.parent, a.slot);
        this.callEffectsAndListeners();
      }
    }
  }
  /** 
   * Create an analysis from a serialized state 
   */
  createFromSerialized(serialized, slotNumber) {
    const splitted = serialized.split(";").map((segment) => segment.trim());
    if (splitted.length < 2) {
      return;
    }
    const name = splitted[0] !== void 0 && splitted[0].length > 0 ? splitted[0] : void 0;
    if (name === void 0) {
      return;
    }
    const type = splitted[1];
    if (!["rectangle", "ellipsis", "point"].includes(type)) {
      return;
    }
    let top = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "top");
    let left = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "left");
    const color = AbstractAnalysis.serializedGetStringValueByKey(splitted, "color");
    let width = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "width");
    let height = AbstractAnalysis.serializedGetNumericalValueByKey(splitted, "height");
    const avg = AbstractAnalysis.serializedSegmentsHasExact(splitted, "avg");
    const min = AbstractAnalysis.serializedSegmentsHasExact(splitted, "min");
    const max = AbstractAnalysis.serializedSegmentsHasExact(splitted, "max");
    if (top !== void 0) {
      if (top < 0) top = 0;
      if (top > this.parent.height - 1) top = this.parent.height - 1;
    }
    if (left !== void 0) {
      if (left < 0) left = 0;
      if (left > this.parent.width - 1) left = this.parent.width - 1;
    }
    let analysis;
    if (type === "point") {
      if (top === void 0 || left === void 0) {
        return;
      }
      analysis = this.parent.analysis.layers.placePointAt(name, top, left, color, false);
    } else {
      if (top === void 0 || left === void 0 || width === void 0 || height === void 0) {
        return;
      }
      if (width < 0) width = 0;
      if (width + left > this.parent.width - 1) width = this.parent.width - left - 1;
      if (height < 0) height = 0;
      if (height + top > this.parent.height - 1) height = this.parent.height - top - 1;
      analysis = type === "rectangle" ? this.parent.analysis.layers.placeRectAt(name, top, left, width + left, height + top, color, false) : this.parent.analysis.layers.placeEllipsisAt(name, top, left, width + left, height + top, color, false);
    }
    if (analysis !== void 0) {
      if (analysis instanceof PointAnalysis) {
        if (avg) analysis.graph.setAvgActivation(true);
      } else if (analysis instanceof AbstractAreaAnalysis) {
        if (avg) analysis.graph.setAvgActivation(true);
        if (min) analysis.graph.setMinActivation(true);
        if (max) analysis.graph.setMaxActivation(true);
      }
      if (slotNumber === false) {
      } else if (slotNumber === true) {
        const nextFreeSlot = this.getNextFreeSlotNumber();
        if (nextFreeSlot !== void 0)
          this.assignSlot(nextFreeSlot, analysis);
      } else if (slotNumber !== void 0) {
        this.assignSlot(slotNumber, analysis);
      }
      return analysis;
    }
  }
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  /** 
   * Internal replacement of standard callbacks call. Here, the value is stored as a map reference, therefore there are no reassignements. Standard callbacks are called upon reassignement. This method is called in their place. 
   */
  callEffectsAndListeners() {
    Object.values(this._listeners).forEach((listener) => listener(this.value));
  }
  /** 
   * Whenever a slot is assigned, call both particular and general listeners 
   */
  emitOnAssignement(slot, value) {
    const assignement = this.getOnAssignementManager(slot);
    if (assignement) assignement.call(value);
    const serialization = this.getOnSerializeManager(slot);
    if (serialization) serialization.call(value ? value.serialized : void 0);
    if (value) {
      this.onSlotInit.call(slot, value);
    } else {
      this.onSlotRemove.call(slot);
    }
  }
  /** 
   * Whenever a slit serializes call the particular manager 
   */
  emitSerializedValue(slot, value) {
    const manager = this.getOnSerializeManager(slot);
    if (manager) {
      manager.call(value);
    }
  }
  /**
   * Get a callback manager that is triggered upon a slot serialisation
   */
  getOnSerializeManager(slot) {
    if (slot === 1) return this.onSlot1Serialize;
    else if (slot === 2) return this.onSlot2Serialize;
    else if (slot === 3) return this.onSlot3Serialize;
    else if (slot === 4) return this.onSlot4Serialize;
    else if (slot === 5) return this.onSlot5Serialize;
    else if (slot === 6) return this.onSlot6Serialize;
    else if (slot === 7) return this.onSlot7Serialize;
  }
  /**
   * Get a callback manager that is triggered whenever a slot is assigned
   */
  getOnAssignementManager(slot) {
    if (slot === 1) return this.onSlot1Assignement;
    else if (slot === 2) return this.onSlot2Assignement;
    else if (slot === 3) return this.onSlot3Assignement;
    else if (slot === 4) return this.onSlot4Assignement;
    else if (slot === 5) return this.onSlot5Assignement;
    else if (slot === 6) return this.onSlot6Assignement;
    else if (slot === 7) return this.onSlot7Assignement;
  }
  /**
   * Get value of a given slot
   */
  getSlotValue(slot) {
    if (this.hasSlot(slot)) {
      return this.getSlot(slot)?.serialized;
    }
  }
  /** 
   * Call a function on every existing slot skipping empty slots. 
   */
  forEveryExistingSlot(fn) {
    const forSlot = (num) => {
      const slot = this.getSlot(num);
      if (slot) {
        fn(slot, num);
      }
    };
    for (let i = 1; i <= 7; i++) {
      forSlot(i);
    }
  }
};

// src/properties/cursor/CursorValueDrive.ts
var CursorValueDrive = class extends AbstractProperty {
  validate(value) {
    return value;
  }
  // Once the value changes, project it to the cursor layer
  afterSetEffect() {
  }
  recalculateFromCursor(position) {
    if (position)
      this.value = this._getValueAtCoordinate(position.x, position.y);
  }
  _getValueAtCoordinate(x, y) {
    if (x === void 0 || y === void 0 || x === this.parent.meta.width || y === this.parent.meta.height) {
      return void 0;
    }
    const index = x + y * this.parent.meta.width;
    const value = this.parent.pixels[index];
    return value;
  }
};

// src/properties/time/playback/TimelineDrive.ts
import { format as format3 } from "date-fns";

// src/properties/time/playback/internals/FrameBuffer.ts
var FrameBuffer = class {
  constructor(drive, firstFrame) {
    this.drive = drive;
    this.currentFrame = firstFrame;
  }
  /** @internal use accessors to get and set with side effects */
  _currentFrame;
  /** The current frame data @readonly */
  get currentFrame() {
    return this._currentFrame;
  }
  /** Upon every update of current frame, propagate current pixels to the instance */
  set currentFrame(frame) {
    this._currentFrame = frame;
    this.drive.parent.setPixels(this.currentFrame.pixels);
  }
  /** Get the current step value calculated from _currentFrame */
  get currentStep() {
    return this.drive.stepsByAbsolute.get(this._currentFrame.timestamp);
  }
  /** Number of images to preload at once */
  bufferSize = 3;
  /** The actual buffer holding pair of step & frame */
  buffer = /* @__PURE__ */ new Map();
  /** Accessor to array of steps preloaded in the given moment */
  get preloadedSteps() {
    return Array.from(this.buffer.keys());
  }
  /** Accessor to array of relative timestamps preloaded in the given moment */
  get preloadedTimestampsRelative() {
    return this.preloadedSteps.map((step) => step.relative);
  }
  async init() {
    return await this.preloadAfterFrameSet(this.currentStep);
  }
  /**
   * Activate a step
   * - look for the buffer for the corresponding frame
   * - if there is a corresponding frame, apply it
   * - if there is none, fetch it
   * - if sequence, fetch buffer
   * 
   * **THIS IS THE MAIN SETTER**
   */
  async recieveStep(step) {
    let frame = this.buffer.get(step);
    if (frame === void 0) {
      frame = await this.drive.parent.reader.frameData(step.index);
    }
    this.currentFrame = frame;
    const status = await this.preloadAfterFrameSet(step);
    return status;
  }
  /** Preload frame data to the buffer based on the provided step */
  async preloadAfterFrameSet(step) {
    const subsetStart = step.index + 1 < this.drive.relativeSteps.length ? step.index + 1 : NaN;
    const subsetEnd = isNaN(subsetStart) ? NaN : this.drive._validateIndex(subsetStart + this.bufferSize);
    if (isNaN(subsetStart) || isNaN(subsetEnd) || subsetStart > subsetEnd || subsetStart === subsetEnd) {
      if (step.relative === this.drive.parent.duration) {
        this.buffer.clear();
      }
      return {
        absoluteTime: this.drive.currentStep.absolute,
        relativeTime: this.drive.value,
        currentFrame: this.currentFrame,
        currentStep: this.currentStep,
        buffer: this.preloadedSteps,
        preloaded: false,
        hasChanged: true
      };
    }
    const stepsThatShouldBe = Array.from(this.drive.stepsByIndex.values()).filter((step2) => {
      return step2.index >= subsetStart && step2.index < subsetEnd;
    });
    const newSteps = stepsThatShouldBe.filter((step2) => !this.preloadedSteps.includes(step2));
    const newFrames = await Promise.all(newSteps.map((step2) => {
      return this.drive.parent.reader.frameData(step2.index);
    }));
    newFrames.forEach((frame, index) => {
      const step2 = newSteps[index];
      this.buffer.set(step2, frame);
    });
    this.preloadedSteps.forEach((step2) => {
      if (!stepsThatShouldBe.includes(step2)) {
        this.buffer.delete(step2);
      }
    });
    return {
      absoluteTime: this.drive.currentStep.absolute,
      currentFrame: this.currentFrame,
      currentStep: this.currentStep,
      relativeTime: this.drive.value,
      buffer: this.preloadedSteps,
      preloaded: true,
      hasChanged: true
    };
  }
};

// src/properties/time/playback/TimelineDrive.ts
var playbackSpeed = {
  1: 1,
  0.5: 2,
  2: 0.5,
  3: 0.333333333333,
  5: 0.25,
  10: 0.1
};
var TimelineDrive = class extends AbstractProperty {
  constructor(parent, initial, steps, initialFrameData) {
    super(parent, Math.max(Math.min(initial, steps.length), 0));
    this.steps = steps;
    this._currentStep = this.steps[this._initial];
    this.startTimestampRelative = 0;
    this.endTimestampRelative = this.steps[this.steps.length - 1].relative;
    this.isSequence = this.parent.timelineData.length > 1;
    this.steps.forEach((step) => {
      this.stepsByIndex.set(step.index, step);
      this.stepsByAbsolute.set(step.absolute, step);
      this.stepsByRelative.set(step.relative, step);
      this.relativeSteps.push(step.relative);
    });
    this.buffer = new FrameBuffer(this, initialFrameData);
  }
  _playbackSpeed = 1;
  get playbackSpeed() {
    return this._playbackSpeed;
  }
  set playbackSpeed(value) {
    this._playbackSpeed = value;
    this.callbackdPlaybackSpeed.call(this._playbackSpeed);
  }
  get playbackSpeedAspect() {
    return playbackSpeed[this.playbackSpeed];
  }
  get duration() {
    return this.parent.duration;
  }
  get frameCount() {
    return this.steps.length;
  }
  startTimestampRelative;
  /** @deprecated not in use? */
  endTimestampRelative;
  stepsByAbsolute = /* @__PURE__ */ new Map();
  stepsByRelative = /* @__PURE__ */ new Map();
  stepsByIndex = /* @__PURE__ */ new Map();
  relativeSteps = [];
  _currentStep;
  get currentStep() {
    return this._currentStep;
  }
  isSequence;
  _isPlaying = false;
  get isPlaying() {
    return this._isPlaying;
  }
  timer;
  buffer;
  // Callbacks & Listeners
  callbackdPlaybackSpeed = new CallbacksManager();
  callbacksPlay = new CallbacksManager();
  callbacksPause = new CallbacksManager();
  callbacksStop = new CallbacksManager();
  callbacksEnd = new CallbacksManager();
  callbacksChangeFrame = new CallbacksManager();
  get currentMs() {
    return this.currentStep.relative;
  }
  get currentPercentage() {
    return this._convertRelativeToPercent(this.currentStep.relative);
  }
  get currentFrameIndex() {
    return this.currentStep.index;
  }
  get currentTime() {
    return this.formatDuration(this.currentStep.relative);
  }
  get frames() {
    return this.parent.meta.current.timeline;
  }
  init() {
    this.buffer.init();
  }
  afterSetEffect() {
    if (this.steps.length === 1) {
      return;
    }
  }
  validate(value) {
    if (this.steps === void 0) {
      return value;
    }
    if (this.steps.length === 1) {
      return 0;
    }
    return this._validateRelativeTime(value);
  }
  _validateRelativeTime(value) {
    return Math.max(Math.min(value, this.steps[this.steps.length - 1].relative), 0);
  }
  _validateIndex(value) {
    return Math.max(Math.min(value, this.steps.length), 0);
  }
  _convertRelativeToAspect(relativeTimeInMs) {
    return relativeTimeInMs / this.duration;
  }
  _convertRelativeToPercent(relativeTimeInMs) {
    return this._convertRelativeToAspect(relativeTimeInMs) * 100;
  }
  _convertPercenttRelative(percent) {
    return this.duration * percent / 100;
  }
  formatDuration(ms) {
    const date = /* @__PURE__ */ new Date(0);
    date.setMilliseconds(ms);
    return format3(date, "mm:ss:SSS");
  }
  next() {
    const next = this.findNextRelative(this.value);
    if (next) {
      this.setRelativeTime(next.relative);
    }
  }
  prev() {
    const prev = this.findPreviousRelative(this.value);
    this.setRelativeTime(prev.relative);
  }
  findPreviousOrThis(relativeTimeInMs) {
    if (this.stepsByRelative.has(relativeTimeInMs)) {
      return this.stepsByRelative.get(relativeTimeInMs);
    }
    return this.findPreviousRelative(relativeTimeInMs);
  }
  /**
   * Find previous frame by relative ms.
   */
  findPreviousRelative(relativeTimeInMs) {
    if (this.steps.length === 1) {
      return this.steps[0];
    }
    relativeTimeInMs = this._validateRelativeTime(relativeTimeInMs);
    const aspect = this._convertRelativeToAspect(relativeTimeInMs);
    let index = Math.max(Math.ceil(aspect * this.steps.length) + 5, this.steps.length);
    let previous = void 0;
    while (index >= 0 && previous === void 0) {
      const step = this.stepsByIndex.get(index);
      if (step !== void 0) {
        if (step.relative < relativeTimeInMs) {
          previous = step;
        }
      }
      index = index - 1;
    }
    const result = previous !== void 0 ? previous : this.steps[0];
    return result;
  }
  findNextRelative(relativeTimeInMs) {
    if (this.steps.length === 1) {
      return this.steps[0];
    }
    const aspect = this._convertRelativeToAspect(relativeTimeInMs);
    const index = Math.floor(aspect * this.steps.length) - 5;
    const subarrayStart = this._validateIndex(index);
    const subarrayEnd = this._validateIndex(index + 40);
    const subarray = this.steps.slice(subarrayStart, subarrayEnd);
    const frame = subarray.find((f) => {
      return f.relative > relativeTimeInMs;
    });
    return frame !== void 0 ? frame : false;
  }
  async setRelativeTime(relativeTimeInMs) {
    relativeTimeInMs = this._validateRelativeTime(relativeTimeInMs);
    this.value = relativeTimeInMs;
    const currentStep = this.findPreviousOrThis(this.value);
    if (currentStep !== this._currentStep) {
      this._currentStep = currentStep;
      const result = await this.buffer.recieveStep(this._currentStep);
      this.callbacksChangeFrame.call(this._currentStep);
      return result;
    }
    return {
      absoluteTime: this._currentStep.absolute,
      relativeTime: this.value,
      currentStep: this._currentStep,
      currentFrame: this.buffer.currentFrame,
      buffer: [],
      preloaded: false,
      hasChanged: false
    };
  }
  async setValueByPercent(percent) {
    percent = Math.max(Math.min(percent, 100), 0);
    const convertedToRelativeTime = this._convertPercenttRelative(percent);
    return await this.setRelativeTime(convertedToRelativeTime);
  }
  /** This is the main play method */
  createNextStepTimer() {
    if (this.timer !== void 0) {
      clearTimeout(this.timer);
    }
    if (!this.isSequence || this._isPlaying === false) {
      return;
    }
    this.timer = setTimeout(() => {
      const next = this.findNextRelative(this._currentStep.relative);
      if (next) {
        this.value = next.relative;
        if (this._isPlaying) {
          this.value = next.relative;
          this._currentStep = next;
          this.buffer.recieveStep(next);
          this.callbacksChangeFrame.call(next);
          this.createNextStepTimer();
        }
      } else {
        this._isPlaying = false;
        this.callbacksEnd.call();
      }
    }, this._currentStep.offset * this.playbackSpeedAspect);
  }
  play() {
    if (this.steps.length > 1) {
      this._isPlaying = true;
      this.createNextStepTimer();
      this.callbacksPlay.call();
    }
  }
  pause() {
    this._isPlaying = false;
    clearTimeout(this.timer);
    this.callbacksPause.call();
  }
  stop() {
    this.pause();
    this.value = 0;
    this.callbacksStop.call();
  }
};

// src/properties/time/recording/RecordingDrive.ts
var RecordingDrive = class extends AbstractProperty {
  stream;
  recorder;
  mimeType;
  _isRecording = false;
  _mayStop = true;
  get mayStop() {
    return this._mayStop;
  }
  set mayStop(value) {
    this._mayStop = value;
    this.callbackMayStop.call(this.mayStop);
  }
  recordedChunks = [];
  callbackMayStop = new CallbacksManager();
  validate(value) {
    return value;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  afterSetEffect(value) {
  }
  start() {
    if (this.value === true) {
      throw new Error("Recording already in process - can not start another one");
    }
    const { stream, recorder } = this.initRecording();
    this.stream = stream;
    this.recorder = recorder;
    this.value = true;
    this.recorder.addEventListener("dataavailable", (event) => {
      if (event.data.size > 0) {
        this.recordedChunks.push(event.data);
        this.download();
        this.clearRecording();
      }
    });
    this.recorder.start();
  }
  end() {
    if (this.value === false) {
      throw new Error("Recording has not started yet - can not end it!");
    }
    if (this.recorder === void 0) {
      throw new Error("Error ending recording - no MediaRecorder instance created.");
    }
    this.recorder.stop();
    this.value = false;
    this.mayStop = true;
  }
  /** Records the entire file from start to the end. */
  async recordEntireFile() {
    if (this.value === true) {
      throw new Error("Already recording the entire file. Can not start until the current recording ends.");
    }
    await this.parent.timeline.setValueByPercent(0);
    this.mayStop = false;
    const cllbackId = "recording entire file";
    this.parent.timeline.callbacksEnd.add(cllbackId, () => {
      this.end();
      this.parent.timeline.callbacksEnd.delete(cllbackId);
    });
    this.parent.timeline.play();
    this.start();
  }
  initRecording() {
    if (this.stream || this.recorder) {
      throw new Error("Recording was already initialised! Can not initialise it again until it stops!");
    }
    const stream = this.parent.canvasLayer.canvas.captureStream(25);
    const types = [
      "video/mp4",
      "video/webm;codecs=h264",
      "video/webm;codecs=vp8",
      "video/webm;codecs=daala",
      "video/webm"
    ];
    types.forEach((type) => {
      if (this.mimeType === void 0 && MediaRecorder.isTypeSupported(type))
        this.mimeType = type;
    });
    const options = {
      mimeType: this.mimeType
    };
    const recorder = new MediaRecorder(stream, options);
    return {
      stream,
      recorder,
      options
    };
  }
  download() {
    const blob = new Blob(this.recordedChunks, {
      type: this.mimeType
    });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.style.display = "none";
    a.href = url;
    a.download = this.parent.fileName.replace(".lrc", `__${this.parent.group.registry.palette.value}__from-${this.parent.group.registry.range.value.from.toFixed(2)}_to-${this.parent.group.registry.range.value.to.toFixed(2)}.webm`);
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
  }
  clearRecording() {
    if (this.recorder) {
      this.recorder.stop();
      delete this.recorder;
    }
    if (this.stream) {
      delete this.stream;
    }
    if (this.recordedChunks.length > 0) {
      this.recordedChunks = [];
    }
    this.value = false;
    this.mimeType = void 0;
  }
};

// src/base/BaseStructureObject.ts
var BaseStructureObject = class {
};

// src/file/dom/InstanceDom.ts
var InstanceDOM = class _InstanceDOM {
  constructor(parent, root) {
    this.parent = parent;
    this.root = root;
    this.root.classList.add(_InstanceDOM.CLASS_BASE);
    this.root.dataset.thermalInstanceId = this.parent.id;
    this.root.dataset.thermalInstanceUrl = this.parent.thermalUrl;
  }
  static CLASS_BASE = "thermalImageRoot";
  static CLASS_BUILT = _InstanceDOM.CLASS_BASE + "__built";
  static CLASS_HYDRATED = _InstanceDOM.CLASS_BASE + "__mounted";
  static CLASS_HOVER = _InstanceDOM.CLASS_BASE + "__hover";
  _built = false;
  get built() {
    return this._built;
  }
  setBuilt(value) {
    this._built = value;
    if (value === true) {
      this.root.classList.add(_InstanceDOM.CLASS_BUILT);
      this.root.dataset.built = "true";
      this.root.style.transition = "border-color .1s ease-in-out";
      this.root.style.zIndex = "10";
      this.root.style.position = "relative";
      this.root.style.lineHeight = "0";
    } else {
      this.root.classList.remove(_InstanceDOM.CLASS_BUILT);
      delete this.root.dataset.built;
      this.root.style.removeProperty("transition");
      this.root.style.removeProperty("zIndex");
      this.root.style.removeProperty("position");
      this.root.style.removeProperty("lineHeight");
    }
  }
  _hydrated = false;
  get hydrated() {
    return this._hydrated;
  }
  setHydrated(value) {
    this._hydrated = value;
    if (value === true) {
      this.root.classList.add(_InstanceDOM.CLASS_HYDRATED);
      this.root.dataset.hydrated = "true";
    } else {
      this.root.classList.remove(_InstanceDOM.CLASS_HYDRATED);
      delete this.root.dataset.hydrated;
    }
  }
  _hover = false;
  get hover() {
    return this._hover;
  }
  setHover(value) {
    this._hover = value;
    if (value === true) {
      this.root.classList.add(_InstanceDOM.CLASS_HOVER);
      this.root.dataset.hover = "true";
    } else {
      this.root.classList.remove(_InstanceDOM.CLASS_HOVER);
      delete this.root.dataset.hover;
    }
  }
  // Layers
  /** The layer holding the canvas element and also analysis DOM */
  _canvasLayer;
  get canvasLayer() {
    return this._canvasLayer;
  }
  /** Visible layer holding an eventual visible object */
  _visibleLayer;
  get visibleLayer() {
    return this._visibleLayer;
  }
  /** Cursor layer will draw the cursor and its label on top of everything */
  _cursorLayer;
  get cursorLayer() {
    return this._cursorLayer;
  }
  /** Listener layer is on top of everything and it handles all mouse events */
  _listenerLayer;
  get listenerLayer() {
    return this._listenerLayer;
  }
  /**
   * Use the parent's create inner method to build and assign all inner DOM
   */
  build() {
    if (this.root !== null && this.built === true) {
      console.info(`Building instance ${this.parent.id} which is already built. Destroying any previous DOM and creating a new one in a new container ${this.root.nodeName}`);
      this.destroy();
    }
    const dom = this.parent.createInnerDom();
    this._canvasLayer = dom.canvasLayer;
    this._visibleLayer = dom.visibleLayer;
    this._cursorLayer = dom.cursorLayer;
    this._listenerLayer = dom.listenerLayer;
    this._canvasLayer.mount();
    this._visibleLayer.mount();
    this._cursorLayer.mount();
    this._listenerLayer.mount();
    this.root.appendChild(this._visibleLayer.getLayerRoot());
    this.root.appendChild(this._canvasLayer.getLayerRoot());
    this.root.appendChild(this._cursorLayer.getLayerRoot());
    this.root.appendChild(this._listenerLayer.getLayerRoot());
    this.setBuilt(true);
  }
  /** Destroy the entire DOM and remove all listeners */
  destroy() {
    if (this.built === true) {
      if (this._canvasLayer) {
        this._canvasLayer.unmount();
        delete this._canvasLayer;
        this._canvasLayer = void 0;
      }
      if (this._visibleLayer) {
        this._visibleLayer.unmount();
        delete this._visibleLayer;
        this._visibleLayer = void 0;
      }
      if (this._cursorLayer) {
        this._cursorLayer.unmount();
        delete this._cursorLayer;
        this._cursorLayer = void 0;
      }
      if (this._listenerLayer) {
        if (this.hydrated === true) {
          this.dehydrate();
        }
        this._listenerLayer.unmount();
        delete this._listenerLayer;
        this._listenerLayer = void 0;
      }
      this.setBuilt(false);
      this.root.classList.remove(_InstanceDOM.CLASS_BASE);
      delete this.root.dataset.thermalInstanceId;
      delete this.root.dataset.thermalInstanceUrl;
      this.root.innerHTML = "";
    }
  }
  /** Activate all listeners */
  hydrate() {
    if (this.listenerLayer === void 0) {
      console.error(`Instance ${this.parent.thermalUrl} does not have a listener layer yet when trying to hydrate! Stopping hydration.`);
      return;
    }
    if (this.hydrated === true) {
      this.dehydrate();
    }
    this.parent.hydrateListener(this);
    this.setHydrated(true);
  }
  /** Deactivate all listeners */
  dehydrate() {
    if (this.hydrated === false) {
      console.error(`Trying to dehydrate the instance ${this.parent.thermalUrl} which is not yet hydrated!}`);
      return;
    }
    if (this.listenerLayer === void 0) {
      console.error(`Trying to dehydrate the instance ${this.parent.thermalUrl} which does not have a listener layer yet!`);
      return;
    }
    this.parent.dehydrateListener(this);
    this.setHydrated(false);
  }
};

// src/file/utils/FileMeta.ts
var FileMeta = class {
  _current;
  get current() {
    return this._current;
  }
  _onChange;
  /** 
   * Lazyloaded callback manager that is triggered whenever the value changes 
   */
  get onChange() {
    if (!this._onChange) {
      this._onChange = new CallbacksManager();
    }
    return this._onChange;
  }
  get width() {
    return this.current.width;
  }
  get height() {
    return this.current.height;
  }
  constructor(baseInfo2) {
    this._current = baseInfo2;
  }
  set(value) {
    this._current = value;
    this.onChange.call(this.current);
  }
};

// src/file/AbstractFile.ts
var AbstractFile = class extends BaseStructureObject {
  id;
  /** Internal limit for cursor label position */
  horizontalLimit;
  /** Internal limit for cursor label position */
  verticalLimit;
  group;
  get pool() {
    return this.group.registry.manager.pool;
  }
  thermalUrl;
  visibleUrl;
  fileName;
  signature = "unknown";
  version = -1;
  streamCount = -1;
  fileDataType = -1;
  unit = -1;
  /** Stored core information. They may change in time because of filters. */
  meta;
  /** @deprecated Use meta instead */
  get width() {
    return this.meta.current.width;
  }
  /** @deprecated Use meta instead */
  get height() {
    return this.meta.current.height;
  }
  /** @deprecated Use meta instead */
  get timestamp() {
    return this.meta.current.timestamp;
  }
  /** @deprecated Use meta instead */
  get duration() {
    return this.meta.current.duration;
  }
  /** @deprecated Use meta instead */
  get min() {
    return this.meta.current.min;
  }
  /** @deprecated Use meta instead */
  get max() {
    return this.meta.current.max;
  }
  /** @deprecated Use meta instead */
  get bytesize() {
    return this.meta.current.bytesize;
  }
  /** @deprecated Use meta instead */
  get averageEmissivity() {
    return this.meta.current.averageEmissivity;
  }
  /** @deprecated Use meta instead */
  get averageReflectedKelvins() {
    return this.meta.current.averageReflectedKelvins;
  }
  /** @deprecated Use meta instead */
  get timelineData() {
    return this.meta.current.timeline;
  }
  /** @deprecated Use meta instead */
  get fps() {
    return this.meta.current.fps;
  }
  /** @deprecated Use meta instead */
  get frameCount() {
    return this.meta.current.frameCount;
  }
  _dom;
  get dom() {
    return this._dom;
  }
  get hover() {
    if (this.dom)
      return this.dom.hover;
    return false;
  }
  // DOM root
  /** @deprecated use DOM object instead */
  get root() {
    if (this.dom) {
      return this.dom.root;
    }
    return null;
  }
  // DOM layers
  /** @deprecated use DOM object instead */
  get canvasLayer() {
    return this.dom.canvasLayer;
  }
  /** @deprecated use DOM object instead */
  get visibleLayer() {
    return this.dom.visibleLayer;
  }
  /** @deprecated use DOM object instead */
  get cursorLayer() {
    return this.dom.cursorLayer;
  }
  /** @deprecated use DOM object instead */
  get listenerLayer() {
    return this.dom.listenerLayer;
  }
  // Drives
  timeline;
  cursorValue;
  analysis;
  // Recording is lazyloaded
  recording;
  /** @deprecated use DOM object instead */
  _mounted = false;
  /** @deprecated use DOM object instead */
  get mounted() {
    return this._mounted;
  }
  /** @deprecated use DOM object instead */
  set mounted(value) {
    this._mounted = value;
  }
  /** @deprecated use DOM object instead */
  _built = false;
  /** @deprecated use DOM object instead */
  get built() {
    return this._built;
  }
  /** @deprecated use DOM object instead */
  set built(value) {
    this._built = value;
  }
  _pixels;
  get pixels() {
    return this._pixels;
  }
  setPixels(value) {
    this._pixels = value;
    this.onSetPixels(value);
  }
  constructor(group, baseInfo2, initialPixels, thermalUrl, visibleUrl) {
    super();
    this.group = group;
    this.id = this.formatId(thermalUrl);
    this.meta = new FileMeta(baseInfo2);
    this.thermalUrl = thermalUrl;
    this.visibleUrl = visibleUrl;
    this.fileName = this.thermalUrl.substring(this.thermalUrl.lastIndexOf("/") + 1);
    this.horizontalLimit = this.width / 4 * 3;
    this.verticalLimit = this.height / 4 * 3;
    this._pixels = initialPixels;
  }
  mountToDom(container) {
    if (this._dom !== void 0) {
      this._dom.destroy();
      this._dom = void 0;
    }
    this._dom = new InstanceDOM(this, container);
    this._dom.build();
    this._dom.hydrate();
  }
  unmountFromDom() {
    if (this.dom) {
      this.dom.destroy();
    }
    delete this._dom;
    this._dom = void 0;
  }
  async draw() {
    if (this.dom && this.dom.canvasLayer) {
      return await this.dom.canvasLayer.draw();
    }
  }
  recievePalette(palette) {
    palette;
    this.draw();
  }
  /** @deprecated use DOM object instead */
  destroySelfAndBelow() {
    if (this.dom) {
      this.dom.destroy();
    }
  }
  /** @deprecated use DOM object instead */
  removeAllChildren() {
    if (this.dom) {
      this.dom.destroy();
    }
  }
  getTemperatureAtPoint(x, y) {
    const xx = Math.min(this.meta.width - 1, Math.max(0, x));
    const yy = Math.min(this.meta.height - 1, Math.max(0, y));
    const index = yy * this.width + xx;
    return this.pixels[index];
  }
  getColorAtPoint(x, y) {
    const temperature = this.getTemperatureAtPoint(x, y);
    const min = this.group.registry.range.value?.from;
    const max = this.group.registry.range.value?.to;
    if (min !== void 0 && max !== void 0) {
      const temperatureRelative = temperature - min;
      const temperatureAspect = temperatureRelative / (max - min);
      const colorIndex = Math.round(255 * temperatureAspect);
      return this.group.registry.palette.currentPalette.pixels[colorIndex];
    }
    return void 0;
  }
  recieveRange(value) {
    if (value !== void 0) {
      this.draw();
    }
  }
  reset() {
  }
  recieveOpacity(value) {
    if (this.dom && this.dom.visibleLayer && this.dom.canvasLayer && this.visibleUrl) {
      this.dom.canvasLayer.opacity = value;
    }
  }
};

// src/file/dom/layers/AbstractLayer.ts
var AbstractLayer = class {
  constructor(instance) {
    this.instance = instance;
  }
  _mounted = false;
  get mounted() {
    return this._mounted;
  }
  mount() {
    if (!this._mounted) {
      if (this.instance.root !== null) {
        this._mounted = true;
        this.instance.root.appendChild(this.getLayerRoot());
      }
    }
  }
  unmount() {
    if (this._mounted) {
      if (this.instance.dom?.root !== null) {
        this._mounted = false;
        this.instance.dom?.root.removeChild(this.getLayerRoot());
      }
    }
  }
  destroy() {
    this.onDestroy();
  }
};

// src/file/dom/domFactories.ts
var ThermalDomFactory = class _ThermalDomFactory {
  static createCanvasContainer() {
    const container = document.createElement("div");
    container.classList.add("thermalCanvasWrapper");
    container.style.position = "relative";
    container.style.userSelect = "none";
    return container;
  }
  static createCanvas() {
    const canvas = document.createElement("canvas");
    canvas.classList.add("thermalCanvas");
    canvas.style.padding = "0px";
    canvas.style.margin = "0px";
    canvas.style.objectFit = "contain";
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    canvas.style.objectPosition = "top left";
    canvas.style.imageRendering = "pixelated";
    canvas.style.userSelect = "none";
    return canvas;
  }
  static createDateLayerInner() {
    const inner = document.createElement("div");
    inner.classList.add("dateLayerInner");
    inner.style.margin = "0px";
    inner.style.padding = ".3rem 0rem";
    inner.style.backgroundColor = "black";
    inner.style.color = "white";
    inner.style.borderRadius = ".5rem .5rem 0 0";
    inner.style.width = "calc(100% + 4px )";
    inner.style.position = "absolute";
    inner.style.top = "0rem";
    inner.style.left = "-2px";
    inner.style.opacity = "0";
    inner.style.transition = "opacity .1s ease-in-out";
    inner.style.textAlign = "center";
    inner.style.userSelect = "none";
    return inner;
  }
  static createVisibleLayer() {
    const layer = document.createElement("div");
    layer.classList.add("visibleLayer");
    layer.style.margin = "0px";
    layer.style.padding = "0px";
    layer.style.height = "100%";
    layer.style.width = "100%";
    layer.style.position = "absolute";
    layer.style.top = "0px";
    layer.style.left = "0px";
    layer.style.userSelect = "none";
    return layer;
  }
  static createVisibleImage() {
    const img = document.createElement("img");
    img.classList.add("visibleLayerImage");
    img.style.padding = "0px";
    img.style.margin = "0px";
    img.style.objectFit = "contain";
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectPosition = "top left";
    img.style.userSelect = "none";
    return img;
  }
  static createListener() {
    const listener = document.createElement("div");
    listener.classList.add("thermalListener");
    listener.style.margin = "0px";
    listener.style.padding = "0px";
    listener.style.height = "100%";
    listener.style.width = "100%";
    listener.style.position = "absolute";
    listener.style.top = "0px";
    listener.style.left = "0px";
    listener.style.cursor = "pointer";
    listener.style.touchAction = "none";
    listener.style.userSelect = "none";
    listener.setAttribute("id", Math.random().toString());
    return listener;
  }
  static createCursorLayerRoot() {
    const layer = document.createElement("div");
    layer.classList.add("cursorLayerRoot");
    layer.style.width = "100%";
    layer.style.height = "100%";
    layer.style.position = "absolute";
    layer.style.top = "0";
    layer.style.left = "0";
    layer.style.opacity = "0";
    layer.style.overflow = "hidden";
    layer.style.lineHeight = "1rem";
    layer.style.userSelect = "none";
    return layer;
  }
  static createCursorLayerCenter() {
    const container = document.createElement("div");
    container.classList.add("cursorLayerCenter");
    container.style.position = "absolute";
    container.style.top = "0px";
    container.style.left = "0px";
    container.style.width = "0px";
    container.style.height = "0px";
    container.style.userSelect = "none";
    return container;
  }
  static createCursorLayerAxeBase() {
    const axe = document.createElement("div");
    axe.classList.add("cursorLayerAxe");
    axe.style.backdropFilter = "invert(100)";
    axe.style.position = "absolute";
    axe.style.top = "0px";
    axe.style.left = "0px";
    axe.style.content = "";
    axe.style.userSelect = "none";
    return axe;
  }
  static createCursorLayerX() {
    const axeX = _ThermalDomFactory.createCursorLayerAxeBase();
    axeX.classList.add("cursorLayerAxeX");
    axeX.style.width = "1px";
    axeX.style.height = "20px";
    axeX.style.top = "-10px";
    axeX.style.userSelect = "none";
    return axeX;
  }
  static createCursorLayerY() {
    const axeY = _ThermalDomFactory.createCursorLayerAxeBase();
    axeY.classList.add("cursorLayerAxeY");
    axeY.style.width = "20px";
    axeY.style.height = "1px";
    axeY.style.left = "-10px";
    axeY.style.userSelect = "none";
    return axeY;
  }
  static createCursorLayerLabel() {
    const axeLabel = document.createElement("div");
    axeLabel.classList.add("cursorLayerLabel");
    axeLabel.style.position = "absolute";
    axeLabel.style.padding = "1px 3px";
    axeLabel.style.backgroundColor = "rgba( 0,0,0,0.5 )";
    axeLabel.style.color = "white";
    axeLabel.style.whiteSpace = "nowrap";
    axeLabel.style.fontSize = "small";
    axeLabel.style.borderRadius = "5px";
    axeLabel.style.userSelect = "none";
    return axeLabel;
  }
};

// src/file/dom/layers/VisibleLayer.ts
var VisibleLayer = class extends AbstractLayer {
  constructor(instance, _url) {
    super(instance);
    this._url = _url;
    this.container = ThermalDomFactory.createVisibleLayer();
    if (this._url) {
      this.image = ThermalDomFactory.createVisibleImage();
      this.url = this._url;
      this.container.appendChild(this.image);
    }
  }
  container;
  image;
  get url() {
    return this._url;
  }
  set url(value) {
    this._url = value;
    if (this.image && value) {
      this.image.src = value;
    }
  }
  get exists() {
    return this._url !== void 0;
  }
  getLayerRoot() {
    return this.container;
  }
  onDestroy() {
    if (this.image) this.image.remove();
    this.container.remove();
  }
};

// src/file/dom/layers/thermalCanvasLayer.ts
var ThermalCanvasLayer = class extends AbstractLayer {
  get pool() {
    return this.instance.pool;
  }
  container;
  canvas;
  context;
  // protected offscreen: OffscreenCanvas;
  get width() {
    return this.instance.width;
  }
  get height() {
    return this.instance.height;
  }
  get pixels() {
    return this.instance.pixels;
  }
  get from() {
    return this.instance.group.registry.range.currentRange ? this.instance.group.registry.range.currentRange.from : this.instance.min;
  }
  get to() {
    return this.instance.group.registry.range.currentRange ? this.instance.group.registry.range.currentRange.to : this.instance.max;
  }
  _opacity = 1;
  get opacity() {
    return this._opacity;
  }
  set opacity(value) {
    this._opacity = Math.max(Math.min(value, 1), 0);
    if (this._opacity !== 1)
      this.canvas.style.opacity = this._opacity.toString();
    else {
      this.canvas.style.removeProperty("opacity");
    }
  }
  constructor(instance) {
    super(instance);
    this.container = ThermalDomFactory.createCanvasContainer();
    this.canvas = ThermalDomFactory.createCanvas();
    this.canvas.width = this.instance.width;
    this.canvas.height = this.instance.height;
    this.context = this.canvas.getContext("2d");
    this.context.imageSmoothingEnabled = false;
    this.container.appendChild(this.canvas);
    this.opacity = this.instance.group.registry.opacity.value;
  }
  getLayerRoot() {
    return this.container;
  }
  onDestroy() {
    this.canvas.remove();
    this.container.remove();
  }
  /** Returns an array of 255 RGB colors */
  getPalette() {
    return this.instance.group.registry.palette.currentPalette.pixels;
  }
  async draw() {
    const paletteColors = this.getPalette();
    try {
      const analysis = this.instance.analysis.value.map((a) => {
        if (a instanceof PointAnalysis) {
          return [a.getType(), a.key, a.top, a.left, 1, 1];
        }
        return [a.getType(), a.key, a.top, a.left, a.width, a.height];
      });
      const image = await this.pool.exec(async (from, to, width, height, pixels, palette, analysis2) => {
        const canvas = new OffscreenCanvas(width, height);
        const context = canvas.getContext("2d");
        const displayRange = to - from;
        const buffer = analysis2.map((a) => {
          return {
            id: a[1],
            type: a[0],
            min: {
              value: Infinity
            },
            max: {
              value: -Infinity
            },
            avg: {
              value: 0,
              sum: 0,
              count: 0
            }
          };
        });
        for (let x = 0; x < width; x++) {
          for (let y = 0; y < height; y++) {
            const index = x + y * width;
            const rawTemperature = pixels[index];
            let temperature = rawTemperature;
            if (temperature < from)
              temperature = from;
            if (temperature > to)
              temperature = to;
            const temperatureRelative = temperature - from;
            const temperatureAspect = temperatureRelative / displayRange;
            const colorIndex = Math.round(255 * temperatureAspect);
            const color = palette[colorIndex];
            context.fillStyle = color;
            context.fillRect(x, y, 1, 1);
            const isWithin = (x2, y2, la, ta, wa, ha) => {
              const centerX = la + wa / 2;
              const centerY = ta + ha / 2;
              const normalizedX = (x2 - centerX) / (wa / 2);
              const normalizedY = (y2 - centerY) / (ha / 2);
              return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
            };
            analysis2.forEach((a, index2) => {
              const bufferValue = buffer[index2];
              const [type, id, top, left, w, h] = a;
              id;
              if (type === "point") {
                if (x === left && y === top) {
                  bufferValue.avg.value = rawTemperature;
                }
              } else if (type === "rectangle") {
                if (x >= left && x < left + w && y >= top && y < top + h) {
                  if (rawTemperature < bufferValue.min.value) {
                    bufferValue.min.value = rawTemperature;
                  }
                  if (rawTemperature > bufferValue.max.value) {
                    bufferValue.max.value = rawTemperature;
                  }
                  bufferValue.avg.count = bufferValue.avg.count + 1;
                  bufferValue.avg.sum = bufferValue.avg.sum + rawTemperature;
                }
              } else if (type === "ellipsis") {
                if (isWithin(x, y, left, top, width, height)) {
                  if (rawTemperature < bufferValue.min.value) {
                    bufferValue.min.value = rawTemperature;
                  }
                  if (rawTemperature > bufferValue.max.value) {
                    bufferValue.max.value = rawTemperature;
                  }
                  bufferValue.avg.count = bufferValue.avg.count + 1;
                  bufferValue.avg.sum = bufferValue.avg.sum + rawTemperature;
                }
              }
            });
          }
        }
        const stats = buffer.map((a) => {
          return {
            id: a.id,
            min: a.min.value !== Infinity ? a.min.value : void 0,
            max: a.max.value !== -Infinity ? a.max.value : void 0,
            avg: a.type === "point" ? a.avg.value : a.avg.sum / a.avg.count
          };
        });
        const imageData = context.getImageData(0, 0, width, height);
        const result = await createImageBitmap(imageData);
        return {
          image: result,
          stats
        };
      }, [
        this.from,
        this.to,
        this.width,
        this.height,
        this.pixels,
        paletteColors,
        analysis
      ], {});
      image.stats.forEach((a) => {
        const analysis2 = this.instance.analysis.layers.get(a.id);
        analysis2?.dangerouslySetValues(a.avg, a.min, a.max);
      });
      this.context.drawImage(image.image, 0, 0);
      return true;
    } catch (error) {
      if (error instanceof Error) {
        if (error.message === "OffscreenCanvas is not defined") {
          return false;
        }
        console.error(error);
      }
    }
    return false;
  }
  exportAsPng() {
    const image = this.canvas.toDataURL();
    const link = document.createElement("a");
    link.download = this.instance.fileName.replace(".lrc", "_exported.png");
    link.href = image;
    link.click();
  }
};

// src/file/dom/layers/thermalCursorLayer.ts
var ThermalCursorLayer = class extends AbstractLayer {
  layerRoot;
  center;
  axisX;
  axisY;
  label;
  constructor(instance) {
    super(instance);
    this.layerRoot = ThermalDomFactory.createCursorLayerRoot();
    this.center = ThermalDomFactory.createCursorLayerCenter();
    this.axisX = ThermalDomFactory.createCursorLayerX();
    this.axisY = ThermalDomFactory.createCursorLayerY();
    this.label = ThermalDomFactory.createCursorLayerLabel();
    this.layerRoot.appendChild(this.center);
    this.center.appendChild(this.axisX);
    this.center.appendChild(this.axisY);
    this.center.appendChild(this.label);
  }
  // Set visible / invisible
  _show = false;
  get show() {
    return this._show;
  }
  setShow(value) {
    this._show = value;
    this.layerRoot.style.opacity = this._show ? "1" : "0";
  }
  _hover = false;
  get hover() {
    return this._hover;
  }
  set hover(value) {
    this._hover = value;
    this.label.style.backgroundColor = this._hover ? "black" : "rgba( 0,0,0,0.5 )";
  }
  recalculateLabelPosition(x, y) {
    if (this.instance.root === null) {
    } else {
      const aspect = this.instance.root.offsetWidth / this.instance.width;
      const centerX = Math.round(x * aspect);
      const centerY = Math.round(y * aspect);
      const wPx = 100 / this.instance.width / 2;
      const hPx = 100 / this.instance.height / 2;
      this.center.style.left = `calc( ${this.px(centerX)} + ${wPx}%)`;
      this.center.style.top = `calc( ${this.px(centerY)} + ${hPx}%)`;
      if (x > this.instance.width / 3) {
        this.label.style.right = "3px";
        this.label.style.removeProperty("left");
      } else {
        this.label.style.left = "3px";
        this.label.style.removeProperty("right");
      }
      if (y > this.instance.height / 4) {
        if (this.label.style.bottom !== "3px") {
          this.label.style.bottom = "3px";
          this.label.style.removeProperty("top");
        }
      } else {
        if (this.label.style.top !== "3px") {
          this.label.style.top = "3px";
          this.label.style.removeProperty("bottom");
        }
      }
    }
  }
  /** @deprecated */
  setCursor(x, y, value) {
    if (this.instance.root === null) {
    } else {
      this.recalculateLabelPosition(x, y);
      this.label.innerHTML = `${value.toFixed(3)} \xB0C`;
    }
  }
  setLabel(x, y, value) {
    if (this.instance.root === null) {
    } else {
      this.recalculateLabelPosition(x, y);
      this.label.innerHTML = value;
    }
  }
  setValue(value) {
    if (value)
      this.label.innerHTML = `${value.toFixed(3)} \xB0C`;
  }
  resetCursor() {
    this.center.style.top = "0px";
    this.center.style.left = "0px";
    this.label.style.removeProperty("right");
    this.label.style.removeProperty("bottom");
    this.label.style.top = "3px";
    this.label.style.left = "3px";
    this.label.innerHTML = "";
  }
  px(number) {
    return `${number}px`;
  }
  getLayerRoot() {
    return this.layerRoot;
  }
  onDestroy() {
    this.label.remove();
    this.axisX.remove();
    this.axisY.remove();
    this.center.remove();
    this.layerRoot.remove();
  }
};

// src/file/dom/layers/thermalListenerLayer.ts
var ThermalListenerLayer = class extends AbstractLayer {
  container;
  constructor(instance) {
    super(instance);
    this.container = ThermalDomFactory.createListener();
  }
  getLayerRoot() {
    return this.container;
  }
  onDestroy() {
    this.container.remove();
  }
};

// src/loading/workers/AbstractFileResult.ts
var AbstractFileResult = class {
  constructor(thermalUrl, visibleUrl) {
    this.thermalUrl = thermalUrl;
    this.visibleUrl = visibleUrl;
  }
};

// src/loading/workers/ThermalFileReader.ts
var ThermalFileReader = class _ThermalFileReader extends AbstractFileResult {
  constructor(service, buffer, parser2, thermalUrl, visibleUrl, preserveOriginalBuffer) {
    super(thermalUrl, visibleUrl);
    this.service = service;
    this.parser = parser2;
    this._buffer = buffer;
    this.fileName = this.thermalUrl.substring(this.thermalUrl.lastIndexOf("/") + 1);
    if (preserveOriginalBuffer === true) {
      this.originalBuffer = this.copyBuffer(this.buffer);
    }
  }
  /** For the purpose of testing we have a unique ID */
  id = Math.random();
  /** In-memory cache of the `baseInfo` request. This request might be expensive in larger files or in Vario Cam files. Because the return value is allways the same, there is no need to make the call repeatedly. */
  baseInfoCache;
  fileName;
  get pool() {
    return this.service.pool;
  }
  originalBuffer;
  _buffer;
  get buffer() {
    return this._buffer;
  }
  set buffer(value) {
    this._buffer = value;
  }
  isSuccess() {
    return true;
  }
  /** @todo This method relies on the functionality of filters. */
  copyBuffer(buffer) {
    const copiedBuffer = new ArrayBuffer(buffer.byteLength);
    const copiedArray = new Uint8Array(copiedBuffer);
    copiedArray.set(new Uint8Array(buffer));
    return copiedArray.buffer;
  }
  /** Create copy of the self so that the */
  cloneForInstance() {
    return this;
    return new _ThermalFileReader(
      this.service,
      this.buffer,
      this.parser,
      this.thermalUrl,
      this.visibleUrl,
      true
    );
  }
  /** Read the fundamental data of the file. If this method had been called before, return the cached result. */
  async baseInfo() {
    if (this.baseInfoCache) {
      return this.baseInfoCache;
    }
    const baseInfo2 = await this.pool.exec(this.parser.baseInfo, [this.buffer]);
    this.baseInfoCache = baseInfo2;
    return baseInfo2;
  }
  /** 
   * Before requesting a frame, create a dedicated `ArrayBuffer` containing only the frame's data 
   * 
   * **THIS IS SYNCHRONOUSE AND MIGHT BE EXPENSIVE**
   */
  getFrameSubset(frameIndex) {
    return this.parser.getFrameSubset(this.buffer, frameIndex);
  }
  /** Read a given frame
   * @todo Implement index range check
   */
  async frameData(index) {
    const data = this.getFrameSubset(index);
    const result = await this.parser.frameData(data.array, data.dataType);
    return result;
  }
  async pointAnalysisData(x, y) {
    return await this.parser.pointAnalysisData(this.buffer, x, y);
  }
  async rectAnalysisData(x, y, width, height) {
    return await this.parser.rectAnalysisData(this.buffer, x, y, width, height);
  }
  async ellipsisAnalysisData(x, y, width, height) {
    return await this.parser.ellipsisAnalysisData(this.buffer, x, y, width, height);
  }
  /** 
   * Recalculates the core array buffer using all available filters. 
   * 
   * This method does not emit anything - it only changes the array buffer.
   */
  async applyFilters(filters) {
    if (this.originalBuffer === void 0) {
      console.error("trying to apply filters on a filereader template");
      return this;
    }
    this.buffer = this.copyBuffer(this.originalBuffer);
    for (const filter of filters) {
      this.buffer = await filter.apply(this.buffer);
    }
    this.baseInfoCache = void 0;
    await this.baseInfo();
    return this;
  }
  async createInstance(group) {
    const reader = this.cloneForInstance();
    const baseInfo2 = await reader.baseInfo();
    const firstFrame = await reader.frameData(0);
    const instance = Instance.fromService(group, reader, baseInfo2, firstFrame);
    group.files.addFile(instance);
    return instance;
  }
};

// src/utils/AbstractPngExport.ts
import domtoimage from "dom-to-image";
var AbstractPngExport = class _AbstractPngExport {
  static FONT_SIZE_NORMAL = "16px";
  static FONT_SIZE_SMALL = "12px";
  static COLOR_BASE = "black";
  static COLOR_GRAY = "gray";
  static COLOR_LIGHT = "lightgray";
  static WIDTH = "1600px";
  static FONT_FAMILY = "sans-serif";
  static GAP_BASE = "10px";
  static GAP_SMALL = "5px";
  static DEBUG = false;
  wrapper;
  container;
  _exporting = false;
  get exporting() {
    return this._exporting;
  }
  onExportingStatusChange = new CallbacksManager();
  /** 
   * Indicate the exporting status. Internal method only! 
   */
  setExporting(value) {
    this._exporting = value;
    this.onExportingStatusChange.call(this._exporting);
  }
  /** 
   * A helper function creating a DIV with default styles 
   */
  createElementWithText(element, text, fontSize = _AbstractPngExport.FONT_SIZE_NORMAL, fontWeight = "normal", color = _AbstractPngExport.COLOR_BASE) {
    const el = document.createElement(element);
    el.innerHTML = text;
    el.style.fontSize = fontSize;
    el.style.lineHeight = "1em";
    el.style.fontWeight = fontWeight;
    el.style.color = color;
    return el;
  }
  buildWrapper() {
    const element = document.createElement("div");
    if (_AbstractPngExport.DEBUG === false) {
      element.style.position = "absolute";
      element.style.width = "0px";
      element.style.height = "0px";
      element.style.overflow = "hidden";
    }
    return element;
  }
  buildContainer(width, backgroundColor) {
    const element = document.createElement("div");
    element.style.width = width.toFixed(0) + "px";
    element.style.fontSize = _AbstractPngExport.FONT_SIZE_NORMAL;
    element.style.fontFamily = _AbstractPngExport.FONT_FAMILY;
    element.style.color = _AbstractPngExport.COLOR_BASE;
    element.style.backgroundColor = backgroundColor;
    return element;
  }
  clear() {
    this.beforeDomRemoved();
    if (this.wrapper) {
      document.body.removeChild(this.wrapper);
    }
    this.afterDomRemoved();
    delete this.container;
    delete this.wrapper;
  }
  /** Create the core DOM and append it to body */
  buildDom(params) {
    this.wrapper = this.buildWrapper();
    this.container = this.buildContainer(params.width, params.backgroundColor);
    this.wrapper.appendChild(this.container);
    this.onBuildDom(params);
    document.body.prepend(this.wrapper);
  }
  /**
   * Make sure the file name has a valid extension
   */
  makeSureFileNameIsValid(fileName) {
    if (fileName.endsWith(".PNG")) {
      fileName = fileName.replaceAll(".PNG", ".png");
    }
    if (!fileName.endsWith(".png")) {
      fileName = fileName + ".png";
    }
    return fileName;
  }
  async downloadPng(params) {
    const options = this.getFinalParams(params);
    options.fileName = this.makeSureFileNameIsValid(options.fileName);
    if (this.exporting === true) {
      console.warn(`PNG export of ${options.fileName} is already working. New requests are allowed after the export finishes.`);
      return;
    }
    this.setExporting(true);
    this.buildDom(options);
    this.onDownload(options);
  }
  /** A unified way to download an image */
  downloadImage(fileName, container) {
    domtoimage.toPng(container).then((dataUrl) => {
      const link = document.createElement("a");
      link.download = fileName;
      link.href = dataUrl;
      link.click();
      if (_AbstractPngExport.DEBUG === false) {
        this.clear();
      }
      this.setExporting(false);
    });
  }
  buildHorizontalScale(element, min, max, from, to, gradient, bgColor, text, highlight) {
    const elementWidth = element.clientWidth;
    const singleItemWidth = 60;
    const elementOffset = 40;
    const numElements = elementWidth / (singleItemWidth + elementOffset);
    const box = document.createElement("div");
    box.style.width = "100%";
    box.style.position = "relative";
    box.style.paddingLeft = singleItemWidth / 2 + "px";
    box.style.paddingRight = singleItemWidth / 2 + "px";
    box.style.boxSizing = "border-box";
    const scale = document.createElement("div");
    scale.style.width = "100%";
    scale.style.position = "relative";
    scale.style.backgroundColor = bgColor;
    scale.style.height = "30px";
    const minmax = max - min;
    const fromClamped = from - min;
    const toClamped = to - min;
    const rangeFromPercent = fromClamped / minmax * 100;
    const rangeToErcent = toClamped / minmax * 100;
    const range = document.createElement("div");
    range.style.position = "absolute";
    range.style.backgroundImage = gradient;
    range.style.height = "100%";
    range.style.top = "0px";
    range.style.left = rangeFromPercent + "%";
    range.style.width = rangeToErcent - rangeFromPercent + "%";
    scale.appendChild(range);
    box.appendChild(scale);
    const ticks = document.createElement("div");
    ticks.style.width = "100%";
    ticks.style.height = "40px";
    ticks.style.position = "relative";
    const buildTick = (value, highlightTick = false, color, background) => {
      const percent = value / minmax * 100;
      const tick = document.createElement("div");
      tick.style.position = "absolute";
      tick.style.top = "0px";
      tick.style.left = `calc( ${percent}% - ${singleItemWidth / 2}px )`;
      tick.style.width = singleItemWidth + "px";
      tick.style.textAlign = "center";
      tick.style.lineHeight = "0px";
      const val = document.createElement("div");
      const pointer = document.createElement("div");
      const pointerInner = document.createElement("div");
      const pointerScale = 7;
      const pointerScalePx = pointerScale + "px";
      val.innerHTML = (min + value).toFixed(2) + " \xB0C";
      val.style.display = "inline-block";
      val.style.fontSize = _AbstractPngExport.FONT_SIZE_SMALL;
      val.style.lineHeight = "1em";
      val.style.padding = "3px";
      val.style.position = "relative";
      pointer.style.width = "100%";
      pointer.style.height = pointerScalePx;
      pointer.style.textAlign = "center";
      pointer.style.position = "relative";
      pointer.style.lineHeight = "0px";
      pointerInner.style.content = "";
      pointerInner.style.display = "inline-block";
      if (highlightTick) {
        pointerInner.style.width = pointerScale * 2 + "px";
        pointerInner.style.height = pointerScale * 2 + "px";
        pointerInner.style.rotate = "45deg";
        pointerInner.style.backgroundColor = background;
        val.style.backgroundColor = background;
        val.style.zIndex = "99";
        val.style.color = color;
      } else {
        pointerInner.style.width = "1px";
        pointerInner.style.height = pointerScalePx;
        pointerInner.style.backgroundColor = color;
      }
      pointer.appendChild(pointerInner);
      tick.appendChild(pointer);
      tick.appendChild(val);
      ticks.appendChild(tick);
    };
    if (highlight) {
      const area = document.createElement("div");
      area.style.position = "absolute";
      area.style.border = `2px solid ${text}`;
      area.style.height = "100%";
      area.style.boxSizing = "border-box";
      const areaFromPercent = (highlight.from - min) / minmax * 100;
      const areaToPercent = (highlight.to - min) / minmax * 100 - areaFromPercent;
      area.style.left = areaFromPercent + "%";
      area.style.width = areaToPercent + "%";
      scale.appendChild(area);
      buildTick(highlight.from - min, true, "white", bgColor);
      buildTick(highlight.to - min, true, "white", bgColor);
    }
    const onePart = minmax / numElements;
    let currentTickValue = 0;
    while (currentTickValue <= minmax) {
      buildTick(currentTickValue, false, text, "transparent");
      currentTickValue = currentTickValue + onePart;
    }
    buildTick(fromClamped, true, "white", text);
    buildTick(toClamped, true, "white", text);
    box.appendChild(ticks);
    return box;
  }
};

// src/file/utils/FilePngExport.ts
var FilePngExport = class _FilePngExport extends AbstractPngExport {
  constructor(file) {
    super();
    this.file = file;
  }
  static DEFAULT_PARAMS = {
    fileName: "sth",
    width: 1200,
    showAnalysis: true,
    backgroundColor: "white"
  };
  localInstance;
  get canvas() {
    return this.file.canvasLayer.canvas;
  }
  onBuildDom() {
  }
  beforeDomRemoved() {
  }
  afterDomRemoved() {
    this.localInstance?.group.registry.manager.removeRegistry(this.localInstance.group.registry.id);
    delete this.localInstance;
  }
  getFinalParams(params) {
    const fileName = params && params.fileName ? params.fileName : `${this.file.fileName}__export`;
    return {
      ..._FilePngExport.DEFAULT_PARAMS,
      ...params,
      fileName
    };
  }
  onDownload(params) {
    const registryId = Math.random().toString();
    const manager = this.file.group.registry.manager;
    const registry = manager.addOrGetRegistry(registryId);
    const group = registry.groups.addOrGetGroup(registryId);
    manager.palette.setPalette(this.file.group.registry.manager.palette.value);
    registry.range.imposeRange(this.file.group.registry.range.value);
    registry.service.loadFile(this.file.thermalUrl).then(async (result) => {
      if (result instanceof ThermalFileReader) {
        this.localInstance = await result.createInstance(group);
        const relativeTime = this.file.timeline.currentStep.relative;
        if (relativeTime !== 0) {
          this.localInstance.timeline.setRelativeTime(relativeTime);
        }
        if (this.container) {
          const registryMin = this.file.group.registry.minmax.value.min;
          const registryMax = this.file.group.registry.minmax.value.max;
          const highlight = registryMin !== this.file.meta.current.min || registryMax !== this.file.meta.current.max ? { from: this.file.meta.current.min, to: this.file.meta.current.max } : void 0;
          this.container.appendChild(this.buildHorizontalScale(
            this.container,
            registryMin,
            registryMax,
            this.file.group.registry.range.value.from,
            this.file.group.registry.range.value.to,
            this.file.group.registry.palette.currentPalette.gradient,
            "gray",
            "black",
            highlight
          ));
          this.localInstance.mountToDom(this.container);
          const instance = this.localInstance;
          if (instance.dom && instance.dom.visibleLayer) {
            instance.dom.visibleLayer.getLayerRoot().style.display = "none";
          }
          await this.localInstance.draw();
          if (params.showAnalysis && this.file.analysis.value.length > 0) {
            const table = document.createElement("table");
            table.style.width = "100%";
            table.style.borderCollapse = "collapse";
            const header = document.createElement("tr");
            ["Analysis", "AVG", "MIN", "MAX"].forEach((string) => {
              const el = this.createElementWithText(
                "th",
                string,
                _FilePngExport.FONT_SIZE_SMALL,
                void 0,
                _FilePngExport.COLOR_GRAY
              );
              el.style.padding = _FilePngExport.GAP_SMALL + "px";
              el.style.textAlign = "left";
              header.appendChild(el);
            });
            table.appendChild(header);
            this.container.appendChild(table);
            this.file.slots.forEveryExistingSlot((slot, number) => {
              const localAnalysis = this.localInstance?.slots.createFromSerialized(slot.serialized, number);
              if (localAnalysis) {
                const row = document.createElement("tr");
                const name = this.createElementWithText(
                  "td",
                  slot.analysis.name,
                  _FilePngExport.FONT_SIZE_SMALL,
                  void 0,
                  slot.analysis.initialColor
                );
                name.style.borderTop = `1px solid ${_FilePngExport.COLOR_LIGHT}`;
                name.style.padding = `${_FilePngExport.GAP_SMALL}px 0px ${_FilePngExport.GAP_SMALL} 0px`;
                row.appendChild(name);
                const createAndAppendValue = (color, value) => {
                  const td = this.createElementWithText(
                    "td",
                    value ? value.toFixed(3) + " \xB0C" : "",
                    _FilePngExport.FONT_SIZE_SMALL,
                    void 0
                  );
                  td.style.borderTop = `1px solid ${_FilePngExport.COLOR_LIGHT}`;
                  td.style.paddingTop = `${_FilePngExport.GAP_SMALL}px`;
                  td.style.paddingBottom = `${_FilePngExport.GAP_SMALL}px`;
                  row.appendChild(td);
                };
                if (slot.analysis instanceof AbstractAreaAnalysis) {
                  createAndAppendValue(slot.analysis.initialColor, localAnalysis.avg);
                  createAndAppendValue(slot.analysis.initialColor, localAnalysis.min);
                  createAndAppendValue(slot.analysis.initialColor, localAnalysis.max);
                } else if (slot.analysis instanceof PointAnalysis) {
                  createAndAppendValue(slot.analysis.initialColor, localAnalysis.avg);
                  createAndAppendValue(slot.analysis.initialColor);
                  createAndAppendValue(slot.analysis.initialColor);
                }
                table.appendChild(row);
              }
            });
          }
          setTimeout(() => {
            if (this.container) {
              this.downloadImage(
                params.fileName,
                this.container
              );
            }
          }, 1e3);
        }
      }
    });
  }
};

// src/file/instance.ts
var Instance = class _Instance extends AbstractFile {
  constructor(group, reader, baseInfo2, firstFrame) {
    super(
      group,
      baseInfo2,
      firstFrame.pixels,
      reader.thermalUrl,
      reader.visibleUrl
    );
    this.group = group;
    this.reader = reader;
    this.firstFrame = firstFrame;
    this.setPixels(firstFrame.pixels);
  }
  slots;
  /**
   * Exports
   */
  _export;
  /** Lazy-loaded `ThermalFileExport` object */
  get export() {
    if (!this._export) {
      const newExport = new FilePngExport(this);
      this._export = newExport;
    }
    return this._export;
  }
  createInnerDom() {
    return {
      canvasLayer: new ThermalCanvasLayer(this),
      visibleLayer: new VisibleLayer(this, this.visibleUrl),
      cursorLayer: new ThermalCursorLayer(this),
      listenerLayer: new ThermalListenerLayer(this)
    };
  }
  hydrateListener(dom) {
    if (!dom.listenerLayer || !dom.cursorLayer) {
      return;
    }
    const listenerLayerRoot = dom.listenerLayer.getLayerRoot();
    if (!listenerLayerRoot) {
      return;
    }
    dom.parent.analysis.activateListeners(listenerLayerRoot);
    dom.listenerLayer.getLayerRoot().onmousemove = (event) => {
      if (dom.cursorLayer)
        dom.cursorLayer.setShow(true);
      dom.setHover(true);
      const client = dom.parent.meta.width;
      const parent = dom.root.clientWidth;
      const aspect = client / parent;
      const x = Math.round(event.offsetX * aspect);
      const y = Math.round(event.offsetY * aspect);
      dom.parent.group.cursorPosition.recieveCursorPosition({ x, y });
    };
    dom.listenerLayer.getLayerRoot().onmouseleave = () => {
      if (dom.cursorLayer)
        dom.cursorLayer.setShow(false);
      dom.setHover(false);
      dom.parent.group.cursorPosition.recieveCursorPosition(void 0);
    };
  }
  dehydrateListener(dom) {
    dom.parent.analysis.deactivateListeners();
  }
  buildServices() {
    this.cursorValue = new CursorValueDrive(this, void 0);
    this.timeline = new TimelineDrive(this, 0, this.timelineData, this.firstFrame);
    this.timeline.init();
    this.recording = new RecordingDrive(this, false);
    this.analysis = new AnalysisDrive(this, []);
    this.analysisData = new AnalysisDataState(this);
    this.slots = new AnalysisSlotsState(this, /* @__PURE__ */ new Map());
    return this;
  }
  formatId(thermalUrl) {
    return `instance_${this.group.id}_${thermalUrl}`;
  }
  onSetPixels(value) {
    value;
    if (this.dom && this.dom.built) {
      this.draw();
      this.cursorValue.recalculateFromCursor(this.group.cursorPosition.value);
      if (this.group.cursorPosition.value) {
        const label = this.group.tool.value.getLabelValue(this.group.cursorPosition.value.x, this.group.cursorPosition.value.y, this);
        this.dom.cursorLayer?.setLabel(this.group.cursorPosition.value.x, this.group.cursorPosition.value.y, label);
      }
    }
  }
  getPixelsForHistogram() {
    return [];
  }
  static fromService(group, service, baseInfo2, firstFrame) {
    const instance = new _Instance(
      group,
      service,
      baseInfo2,
      firstFrame
    );
    return instance.buildServices();
  }
  recieveCursorPosition(position) {
    if (position !== void 0) {
      const x = Math.min(this.meta.width, Math.max(0, position.x));
      const y = Math.min(this.meta.height, Math.max(0, position.y));
      const label = this.group.tool.value.getLabelValue(x, y, this);
      if (this.dom) {
        this.dom.cursorLayer?.setLabel(x, y, label);
        if (this.dom.cursorLayer)
          this.dom.cursorLayer.setShow(true);
      }
    } else {
      if (this.dom) {
        this.dom.cursorLayer?.resetCursor();
        this.dom.cursorLayer?.setShow(false);
      }
    }
    this.cursorValue.recalculateFromCursor(position);
  }
  filters = new FilterContainer(this);
  getInstances() {
    return [this];
  }
  getAllApplicableFilters() {
    const manager = this.group.registry.manager.filters.getActiveFilters();
    const registry = this.group.registry.filters.getActiveFilters();
    const group = this.group.filters.getActiveFilters();
    const file = this.filters.getActiveFilters();
    return [
      ...manager,
      ...registry,
      ...group,
      ...file
    ];
  }
  async applyAllAvailableFilters() {
    const baseInfo2 = await this.reader.baseInfo();
    const frameData2 = await this.reader.frameData(this.timeline.currentStep.index);
    if (this.root) {
      const container = this.root;
      this.unmountFromDom();
      this.mountToDom(container);
    }
    this.meta.set(baseInfo2);
    this.setPixels(frameData2.pixels);
  }
};

// src/properties/analysis/sync/utils/GroupExportCSV.ts
import { download as download2, generateCsv as generateCsv2, mkConfig as mkConfig2 } from "export-to-csv";
var GroupExportCSV = class {
  constructor(drive) {
    this.drive = drive;
  }
  formatAnalysisDisplayName(analysis, scope) {
    const nameBase = `${analysis.name} (${analysis.getType()}, ${analysis.initialColor}})`;
    if (analysis instanceof AbstractAreaAnalysis && scope) {
      return nameBase + " " + scope.toUpperCase();
    }
    return nameBase;
  }
  formatAnalysisKey(analysis, scope) {
    const keyBase = analysis.key;
    if (analysis instanceof AbstractAreaAnalysis && scope) {
      return keyBase + "_" + scope;
    }
    return keyBase;
  }
  formatFrameSlotValue(slot, scope) {
    if (slot.analysis instanceof AbstractAreaAnalysis && scope) {
      let value = slot.analysis.avg;
      if (scope === "min") value = slot.analysis.min;
      if (scope === "max") value = slot.analysis.max;
      return {
        key: this.formatAnalysisKey(slot.analysis, scope),
        value: value.toString()
      };
    }
    return {
      key: this.formatAnalysisKey(slot.analysis),
      value: slot.analysis.avg.toString()
    };
  }
  /** Assamble the export header and data */
  getData() {
    const header = [
      { key: "file", displayLabel: "File name" },
      { key: "timestamp", displayLabel: "Frame time" },
      { key: "frame", displayLabel: "Frame ID" }
    ];
    this.drive.forEveryExistingSlot((slot) => {
      if (slot.analysis instanceof AbstractAreaAnalysis) {
        header.push({
          key: this.formatAnalysisKey(slot.analysis, "min"),
          displayLabel: this.formatAnalysisDisplayName(slot.analysis, "min")
        });
        header.push({
          key: this.formatAnalysisKey(slot.analysis, "max"),
          displayLabel: this.formatAnalysisDisplayName(slot.analysis, "max")
        });
        header.push({
          key: this.formatAnalysisKey(slot.analysis, "avg"),
          displayLabel: this.formatAnalysisDisplayName(slot.analysis, "avg")
        });
      } else {
        header.push({
          key: this.formatAnalysisKey(slot.analysis),
          displayLabel: this.formatAnalysisDisplayName(slot.analysis)
        });
      }
    });
    const data = [];
    this.drive.parent.files.value.sort((a, b) => {
      return a.timestamp - b.timestamp;
    }).forEach((file) => {
      const row = {
        file: file.fileName,
        timestamp: TimeFormat.human(file.timeline.currentStep.absolute),
        frame: file.timeline.currentStep.index
      };
      file.slots.forEveryExistingSlot((slot) => {
        if (slot.analysis instanceof AbstractAreaAnalysis) {
          const min = this.formatFrameSlotValue(slot, "min");
          const max = this.formatFrameSlotValue(slot, "max");
          const avg = this.formatFrameSlotValue(slot, "avg");
          row[min.key] = min.value;
          row[max.key] = max.value;
          row[avg.key] = avg.value;
        } else {
          const avg = this.formatFrameSlotValue(slot);
          row[avg.key] = avg.value;
        }
      });
      data.push(row);
    });
    return {
      header,
      data
    };
  }
  downloadAsCsv() {
    const group = this.drive.parent;
    const groupIdentificator = group.name ?? group.id ?? group.hash;
    const { header, data } = this.getData();
    const csvConfig = mkConfig2({
      fieldSeparator: ";",
      filename: `group_${groupIdentificator}`,
      columnHeaders: header
    });
    const csv = generateCsv2(csvConfig)(data);
    download2(csvConfig)(csv);
  }
};

// src/properties/analysis/sync/utils/GroupExportPNG.ts
var GroupExportPNG = class _GroupExportPNG extends AbstractPngExport {
  constructor(drive) {
    super();
    this.drive = drive;
  }
  static DEFAULT_PROPS = {
    columns: 3,
    width: 1600,
    showAnalysis: true,
    backgroundColor: "white"
  };
  /** Alias to the group this exporter is attached to */
  get group() {
    return this.drive.parent;
  }
  /** Temporary local group is used to build a mirror of images. */
  localGroup;
  /** The header element with title, description and other stuff */
  header;
  /** Images are mounted to this DIV */
  list;
  buildHeader() {
    const element = document.createElement("div");
    element.style.padding = _GroupExportPNG.GAP_BASE;
    element.style.border = "1px lightgray solid";
    const title = this.createElementWithText(
      "div",
      this.group.label,
      void 0,
      "bold"
    );
    element.appendChild(title);
    if (this.group.description) {
      const description = this.createElementWithText(
        "div",
        this.group.description,
        _GroupExportPNG.FONT_SIZE_SMALL,
        "normal",
        _GroupExportPNG.COLOR_BASE
      );
      description.style.paddingTop = _GroupExportPNG.GAP_SMALL;
      element.appendChild(description);
    }
    const summary = this.createElementWithText(
      "div",
      `${this.group.files.value.length} files. MIN: ${this.group.registry.minmax.value?.min.toFixed(3)} \xB0C. MAX: ${this.group.registry.minmax.value?.max.toFixed(3)} \xB0C.`,
      _GroupExportPNG.FONT_SIZE_SMALL,
      void 0,
      _GroupExportPNG.COLOR_GRAY
    );
    summary.style.paddingTop = _GroupExportPNG.GAP_SMALL;
    element.appendChild(summary);
    const colophon = this.createElementWithText(
      "div",
      `Image exported at ${TimeFormat.human(/* @__PURE__ */ new Date())} at <i>${window.location.href}</i> using LabIR Edu web viewer. More information at <i>https://edu.labir.cz</i>.`,
      _GroupExportPNG.FONT_SIZE_SMALL,
      void 0,
      _GroupExportPNG.COLOR_GRAY
    );
    colophon.style.paddingTop = _GroupExportPNG.GAP_SMALL;
    return element;
  }
  buildList() {
    const element = document.createElement("div");
    element.style.boxSizing = "border-box";
    element.style.width = "100%";
    element.style.display = "flex";
    element.style.flexWrap = "wrap";
    return element;
  }
  buildInstance(instance, width, showAnalysis) {
    const container = document.createElement("div");
    container.style.width = width.toString() + "%";
    container.style.padding = _GroupExportPNG.GAP_SMALL;
    container.style.boxSizing = "border-box";
    const wrapper = document.createElement("div");
    container.appendChild(wrapper);
    const title = this.createElementWithText(
      "div",
      `${TimeFormat.human(instance.timeline.currentStep.absolute)}`,
      _GroupExportPNG.FONT_SIZE_SMALL,
      "bold"
    );
    wrapper.appendChild(title);
    if (this.list) {
      this.group.files.forEveryInstance((i) => {
        if (this.localGroup) {
          const localEquivalent = this.localGroup.files.value.find((value) => {
            return value.fileName === i.fileName;
          });
          if (localEquivalent) {
            localEquivalent.timeline.setRelativeTime(
              i.timeline.value
            );
          }
        }
      });
      this.list.appendChild(container);
      instance.mountToDom(wrapper);
      instance.draw();
      if (instance.dom && instance.dom.visibleLayer) {
        instance.dom.visibleLayer.getLayerRoot().style.display = "none";
      }
      if (showAnalysis) {
        const referenceInstance = this.group.files.value[0];
        if (referenceInstance && referenceInstance.analysis.value.length > 0) {
          const table = document.createElement("table");
          table.style.width = "100%";
          table.style.borderCollapse = "collapse";
          const header = document.createElement("tr");
          ["", "AVG", "MIN", "MAX"].forEach((string) => {
            const el = this.createElementWithText(
              "th",
              string,
              _GroupExportPNG.FONT_SIZE_SMALL,
              void 0,
              _GroupExportPNG.COLOR_GRAY
            );
            el.style.padding = _GroupExportPNG.GAP_SMALL + "px";
            el.style.textAlign = "left";
            header.appendChild(el);
          });
          table.appendChild(header);
          wrapper.appendChild(table);
          referenceInstance.slots.forEveryExistingSlot((slot, number) => {
            const localAnalysis = instance.slots.createFromSerialized(slot.serialized, number);
            if (localAnalysis) {
              const row = document.createElement("tr");
              const name = this.createElementWithText(
                "td",
                slot.analysis.name,
                _GroupExportPNG.FONT_SIZE_SMALL,
                void 0,
                slot.analysis.initialColor
              );
              name.style.borderTop = `1px solid ${_GroupExportPNG.COLOR_LIGHT}`;
              name.style.padding = `${_GroupExportPNG.GAP_SMALL}px 0px ${_GroupExportPNG.GAP_SMALL} 0px`;
              row.appendChild(name);
              const createAndAppendValue = (color, value) => {
                const td = this.createElementWithText(
                  "td",
                  value ? value.toFixed(3) + " \xB0C" : "",
                  _GroupExportPNG.FONT_SIZE_SMALL,
                  void 0
                );
                td.style.borderTop = `1px solid ${_GroupExportPNG.COLOR_LIGHT}`;
                td.style.paddingTop = `${_GroupExportPNG.GAP_SMALL}px`;
                td.style.paddingBottom = `${_GroupExportPNG.GAP_SMALL}px`;
                row.appendChild(td);
              };
              if (slot.analysis instanceof AbstractAreaAnalysis) {
                createAndAppendValue(slot.analysis.initialColor, localAnalysis.avg);
                createAndAppendValue(slot.analysis.initialColor, localAnalysis.min);
                createAndAppendValue(slot.analysis.initialColor, localAnalysis.max);
              } else if (slot.analysis instanceof PointAnalysis) {
                createAndAppendValue(slot.analysis.initialColor, localAnalysis.avg);
                createAndAppendValue(slot.analysis.initialColor);
                createAndAppendValue(slot.analysis.initialColor);
              }
              table.appendChild(row);
            }
          });
        }
      }
    }
  }
  onBuildDom() {
    this.header = this.buildHeader();
    this.list = this.buildList();
    this.container?.appendChild(this.header);
    this.container?.appendChild(this.list);
  }
  beforeDomRemoved() {
    if (this.localGroup) {
      this.localGroup.files.forEveryInstance((instance) => instance.unmountFromDom());
      this.localGroup.files.removeAllInstances();
    }
  }
  afterDomRemoved() {
    delete this.header;
    delete this.list;
    delete this.localGroup;
  }
  onDownload(params) {
    const registryId = Math.random().toFixed();
    const manager = this.group.registry.manager;
    const registry = manager.addOrGetRegistry(registryId);
    const group = registry.groups.addOrGetGroup(this.group.id);
    this.list?.appendChild(this.buildHorizontalScale(
      this.list,
      this.group.registry.minmax.value.min,
      this.group.registry.minmax.value.max,
      this.group.registry.range.value.from,
      this.group.registry.range.value.to,
      this.group.registry.palette.currentPalette.gradient,
      "gray",
      "black"
    ));
    this.localGroup = group;
    manager.palette.setPalette(this.group.registry.manager.palette.value);
    registry.range.imposeRange(this.group.registry.range.value);
    const imagesThermalUrls = this.group.files.sortedFiles.map((file) => file.thermalUrl);
    let batch = void 0;
    imagesThermalUrls.forEach((url) => {
      batch = registry.batch.request(url, void 0, group, async () => {
      });
    });
    batch.onResolve.set("temporary export listener", (results) => {
      const width = 100 / params.columns;
      results.forEach((result) => {
        if (result instanceof Instance) {
          this.buildInstance(result, width, params.showAnalysis);
        }
      });
      setTimeout(() => {
        if (this.container) {
          this.downloadImage(
            params.fileName,
            this.container
          );
        }
      }, 2e3);
    });
  }
  /**
   * Take provided parameters and combine them with defaults and add filename.
   */
  getFinalParams(params) {
    const fileName = params?.fileName ? params.fileName : `group__${this.group.label}__export`;
    if (params === void 0) {
      return {
        ..._GroupExportPNG.DEFAULT_PROPS,
        fileName
      };
    }
    return {
      ..._GroupExportPNG.DEFAULT_PROPS,
      ...params,
      fileName
    };
  }
};

// src/properties/analysis/sync/analysisSync.ts
var AnalysisSyncDrive = class _AnalysisSyncDrive extends AbstractProperty {
  onSlotSync = new CallbacksManager();
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  turnOn(instance) {
    this.value = true;
    this.setCurrentPointer(instance);
    this.syncSlots(instance);
  }
  turnOff() {
    this.value = false;
    this.setCurrentPointer(void 0);
  }
  _currentPointer;
  get currentPointer() {
    return this._currentPointer;
  }
  forEveryExistingSlot(fn) {
    if (this._currentPointer === void 0) {
      return;
    }
    this._currentPointer.slots.forEveryExistingSlot(fn);
  }
  setCurrentPointer(instance) {
    if (instance === void 0 && this._currentPointer) {
      this.endSyncingSlot(this._currentPointer, 1);
      this.endSyncingSlot(this._currentPointer, 2);
      this.endSyncingSlot(this._currentPointer, 3);
      this.endSyncingSlot(this._currentPointer, 4);
      this.endSyncingSlot(this._currentPointer, 5);
      this.endSyncingSlot(this._currentPointer, 6);
      this.endSyncingSlot(this._currentPointer, 7);
    }
    if (instance !== this._currentPointer) {
      if (this._currentPointer !== void 0) {
        this.endSyncingSlot(this._currentPointer, 1);
        this.endSyncingSlot(this._currentPointer, 2);
        this.endSyncingSlot(this._currentPointer, 3);
        this.endSyncingSlot(this._currentPointer, 4);
        this.endSyncingSlot(this._currentPointer, 5);
        this.endSyncingSlot(this._currentPointer, 6);
        this.endSyncingSlot(this._currentPointer, 7);
      }
      this._currentPointer = instance;
      if (this._currentPointer !== void 0) {
        this.startSyncingSlot(this._currentPointer, 1);
        this.startSyncingSlot(this._currentPointer, 2);
        this.startSyncingSlot(this._currentPointer, 3);
        this.startSyncingSlot(this._currentPointer, 4);
        this.startSyncingSlot(this._currentPointer, 5);
        this.startSyncingSlot(this._currentPointer, 6);
        this.startSyncingSlot(this._currentPointer, 7);
      }
    }
  }
  getSlotListeners(instance, slotNumber) {
    const slot = instance.slots.getSlot(slotNumber);
    if (slotNumber === 1) {
      return {
        slot,
        serialise: instance.slots.onSlot1Serialize,
        assign: instance.slots.onSlot1Assignement
      };
    } else if (slotNumber === 2) {
      return {
        slot,
        serialise: instance.slots.onSlot2Serialize,
        assign: instance.slots.onSlot2Assignement
      };
    } else if (slotNumber === 3) {
      return {
        slot,
        serialise: instance.slots.onSlot3Serialize,
        assign: instance.slots.onSlot3Assignement
      };
    } else if (slotNumber === 4) {
      return {
        slot,
        serialise: instance.slots.onSlot4Serialize,
        assign: instance.slots.onSlot4Assignement
      };
    } else if (slotNumber === 5) {
      return {
        slot,
        serialise: instance.slots.onSlot5Serialize,
        assign: instance.slots.onSlot5Assignement
      };
    } else if (slotNumber === 6) {
      return {
        slot,
        serialise: instance.slots.onSlot6Serialize,
        assign: instance.slots.onSlot6Assignement
      };
    } else if (slotNumber === 7) {
      return {
        slot,
        serialise: instance.slots.onSlot7Serialize,
        assign: instance.slots.onSlot7Assignement
      };
    }
  }
  static LISTENER_KEY = "__analysis__sync";
  startSyncingSlot(instance, slotNumber) {
    const { serialise } = this.getSlotListeners(instance, slotNumber);
    serialise.set(_AnalysisSyncDrive.LISTENER_KEY, (value) => {
      this.forEveryOtherSlot(instance, slotNumber, (sl, f) => {
        this.onSlotSync.call(value, slotNumber);
        if (sl === void 0 && value) {
          const analysis = f.slots.createFromSerialized(value, slotNumber);
          analysis?.setSelected();
        } else if (sl !== void 0 && value) {
          sl.recieveSerialized(value);
          this.onSlotSync.call(sl ? sl.serialized : void 0, slotNumber);
        } else if (sl !== void 0 && value === void 0) {
          sl.analysis.file.slots.removeSlotAndAnalysis(slotNumber);
        }
      });
    });
  }
  endSyncingSlot(instance, slotNumber) {
    this.forEveryOtherSlot(instance, slotNumber, () => {
      const { assign, serialise } = this.getSlotListeners(instance, slotNumber);
      assign.delete(_AnalysisSyncDrive.LISTENER_KEY);
      serialise.delete(_AnalysisSyncDrive.LISTENER_KEY);
    });
  }
  deleteSlot(instance, slotNumber) {
    this.forEveryOtherSlot(instance, slotNumber, (slot) => {
      slot?.analysis.file.slots.removeSlotAndAnalysis(slotNumber);
    });
  }
  setSlotSelected(instance, slotNumber) {
    this.forEveryOtherSlot(instance, slotNumber, (slot) => {
      slot?.analysis.setSelected(false);
    });
  }
  setSlotDeselected(instance, slotNumber) {
    this.forEveryOtherSlot(instance, slotNumber, (slot) => {
      slot?.analysis.setDeselected();
    });
  }
  /**
   * Get array of files excludint the one provided
   */
  allExceptOne(instance) {
    return this.parent.files.value.filter((file) => file !== instance);
  }
  /** 
   * Execute a given function on all files slot 
   */
  forEveryOtherSlot(instance, slotNumber, fn) {
    this.allExceptOne(instance).forEach((file) => {
      const item = file.slots.getSlot(slotNumber);
      fn(item, file);
    });
  }
  recieveSlotSerialized(serialized, slot) {
    this.parent.files.forEveryInstance(
      (instance) => {
        if (instance === this.currentPointer) {
          return;
        }
        if (serialized) {
          const sl = instance.slots.getSlot(slot);
          if (sl) {
            sl.recieveSerialized(serialized);
          } else {
            instance.slots.createFromSerialized(serialized, slot);
          }
        } else {
          instance.slots.removeSlotAndAnalysis(slot);
        }
      }
    );
  }
  /** @deprecated Should sync individual slots only. This method synces all slots at once. */
  syncSlots(instance) {
    if (this.value === false) {
      return;
    }
    this.setCurrentPointer(instance);
    const allOtherFiles = this.parent.files.value.filter((file) => file !== instance);
    const map = instance.slots.getSlotMap();
    allOtherFiles.forEach((file) => {
      for (const [slt, value] of map) {
        if (value === void 0) {
          file.slots.removeSlotAndAnalysis(slt);
        } else {
          const existingSerialized = file.slots.getSlot(slt)?.serialized;
          const newSerialized = value.serialized;
          if (existingSerialized !== newSerialized) {
            if (file.slots.hasSlot(slt)) {
              file.slots.getSlot(slt)?.recieveSerialized(newSerialized);
            } else {
              const slot = file.slots.createFromSerialized(newSerialized, slt);
              slot?.setSelected(false);
            }
          }
        }
      }
    });
  }
  _csv;
  /** Lazy loaded CSV export object. */
  get csv() {
    if (!this._csv) {
      this._csv = new GroupExportCSV(this);
    }
    return this._csv;
  }
  _png;
  /** Lazy loaded PNG export object. */
  get png() {
    if (!this._png) {
      this._png = new GroupExportPNG(this);
    }
    return this._png;
  }
};

// src/properties/cursor/CursorPositionDrive.ts
var CursorPositionDrive = class extends AbstractProperty {
  _hover = this.value !== void 0;
  get hover() {
    return this._hover;
  }
  validate(value) {
    return value;
  }
  // After the position changes, update the hover & project the position in all instances
  afterSetEffect(value) {
    this._hover = this.value !== void 0;
    this.parent.files.forEveryInstance((instance) => instance.recieveCursorPosition(value));
  }
  recieveCursorPosition(position) {
    this.value = position;
  }
};

// src/properties/lists/filesState.ts
var FilesState = class extends AbstractProperty {
  _map = /* @__PURE__ */ new Map();
  get map() {
    return this._map;
  }
  validate(value) {
    return value.sort((a, b) => a.timestamp - b.timestamp);
  }
  /** Array of all files sorted by timestamp from the earliest to the latest. */
  get sortedFiles() {
    return this.value.sort((a, b) => {
      return a.timestamp - b.timestamp;
    });
  }
  /**
   * Whenever the instances change, recreate the index
   */
  afterSetEffect(value) {
    this.map.clear();
    value.forEach((instance) => this._map.set(instance.thermalUrl, instance));
  }
  addFile(file) {
    if (!this._map.has(file.thermalUrl)) {
      this.value = [...this.value, file];
      return file;
    } else {
      return this._map.get(file.thermalUrl);
    }
  }
  removeFile(file) {
    const entry = file instanceof Instance ? file : this.map.get(file);
    if (entry) {
      entry.unmountFromDom();
      this.value = this.value.filter((e) => e.thermalUrl !== entry.thermalUrl);
    }
  }
  /**
   * Removal
   */
  removeAllInstances() {
    this.forEveryInstance((instance) => instance.destroySelfAndBelow());
    this.value = [];
  }
  /** 
   * Iteration through all instances
   */
  forEveryInstance(fn) {
    this.value.forEach((instance) => fn(instance));
  }
  downloadAllFiles() {
    this.forEveryInstance((instance) => {
      const link = document.createElement("a");
      link.download = instance.fileName;
      link.href = instance.thermalUrl;
      link.click();
    });
  }
};

// src/properties/scale/abstractMinmaxProperty.ts
var AbstractMinmaxProperty = class extends AbstractProperty {
  /** Get the current distance between min and max */
  get distanceInCelsius() {
    if (this.value === void 0) {
      return void 0;
    }
    return Math.abs(this.value.min - this.value.max);
  }
};

// src/properties/scale/MinmaxGroupProperty.ts
var MinmaxGroupProperty = class extends AbstractMinmaxProperty {
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  /** Call this method once all instances are created */
  recalculateFromInstances() {
    this.value = this._getMinmaxFromInstances();
    return this.value;
  }
  _getMinmaxFromInstances() {
    const instances = this.parent.files.value;
    if (instances.length === 0)
      return void 0;
    return instances.reduce((state, current) => {
      if (current.min < state.min || current.max > state.max) {
        return {
          min: current.min < state.min ? current.min : state.min,
          max: current.max > state.max ? current.max : state.max
        };
      }
      return state;
    }, { min: Infinity, max: -Infinity });
  }
};

// src/properties/time/group/GroupPlayback.ts
var GroupPlayback = class extends AbstractProperty {
  _hasAnyPlayback = false;
  /** Does this group include any sequence? */
  get hasAnyPlayback() {
    return this._hasAnyPlayback;
  }
  set hasAnyPlayback(value) {
    if (this._hasAnyPlayback !== value) {
      this._hasAnyPlayback = value;
      this.onHasAnyCallback.call(value);
    }
  }
  onHasAnyCallback = new CallbacksManager();
  recalculateHasAnyPlayback(instances) {
    let temporaryHas = false;
    instances.forEach((i) => {
      if (i.timeline.isSequence) {
        temporaryHas = true;
      }
    });
    this.hasAnyPlayback = temporaryHas;
  }
  _playing = false;
  get playing() {
    return this._playing;
  }
  set playing(value) {
    if (this._playing !== value) {
      this._playing = value;
      this.onPlayingStatusChange.call(this._playing);
    }
  }
  onPlayingStatusChange = new CallbacksManager();
  /** Internal pointer holding the current loop iteration*/
  loopStep = 0;
  /** Internal setTimeout for playback. */
  loopTimer;
  _loopInterval = 20;
  /** Interval upon which the main loop triggers. In MS. */
  get loopInterval() {
    return this._loopInterval;
  }
  /** @deprecated The playback interval should not change during playback */
  setLoopInterval(value) {
    this._loopInterval = Math.round(value);
    this.onLoopIntervalChanged.call(this._loopInterval);
  }
  /** @deprecated The loop playback should not change during playback */
  onLoopIntervalChanged = new CallbacksManager();
  _duration = 0;
  get duration() {
    return this._duration;
  }
  set duration(value) {
    if (value !== this._duration) {
      this._duration = value;
      this.onDurationChanged.call(this._duration);
    }
  }
  onDurationChanged = new CallbacksManager();
  recalculateDuration(instances) {
    let temporaryDuration = 0;
    instances.forEach((instance) => {
      if (instance.timeline.duration > temporaryDuration) {
        temporaryDuration = instance.timeline.duration;
      }
    });
    this.duration = temporaryDuration;
  }
  UUID = this.parent.id + "__listener";
  constructor(parent, initial) {
    super(parent, initial);
    this.recalculateDuration(this.parent.files.value);
    this.recalculateHasAnyPlayback(this.parent.files.value);
    this.parent.registry.batch.onBatchComplete.set(
      this.UUID,
      (results) => {
        const instances = results.filter((res) => res instanceof Instance);
        this.recalculateDuration(instances);
        this.recalculateHasAnyPlayback(instances);
        const newVal = this.value;
        this.value = newVal;
      }
    );
  }
  validate(value) {
    return Math.min(Math.max(value, 0), this.duration);
  }
  afterSetEffect(value) {
    this.parent.files.forEveryInstance((instance) => instance.timeline.setRelativeTime(value));
  }
  /** Set time value by percent. The actual MS is calculated depending on the duration. */
  setValueByPercent(percent) {
    const ms = this.percentToMs(percent);
    if (ms !== this.value) {
      this.value = ms;
      this.loopStep = Math.floor(this.duration / this.value);
      if (this.playing) {
        this.createTimerStep(true);
      }
    }
  }
  /** Set the time value by MS. */
  setValueByRelativeMs(relativeMs) {
    this.value = relativeMs;
    this.loopStep = Math.floor(this.duration / this.value);
    if (this.playing) {
      this.createTimerStep(true);
    }
  }
  /** Convert percent value to relative time in MS */
  percentToMs(percent) {
    return Math.floor(this.duration * (percent / 100));
  }
  /** Convert relative time in MS to percent value */
  msToPercent(ms) {
    return ms / this.duration * 100;
  }
  /**
   * The main method that shall create a timer leading to the next step.
   * 
   * It might be called recursively to ensure fluent playback.
   */
  createTimerStep(recursive = false) {
    if (this.duration === void 0 || this.playing === false) {
      return;
    }
    const nextStep = this.loopStep + 1;
    const nextValue = nextStep * this.loopInterval;
    this.loopStep = nextStep;
    if (nextValue <= this.duration) {
      if (this.loopTimer) {
        clearTimeout(this.loopTimer);
      }
      this.loopTimer = setTimeout(() => {
        this.createTimerStep(recursive);
        this.value = nextValue;
      }, this.loopInterval);
    } else {
      this.playing = false;
    }
  }
  /**
   * Play the entire group
   */
  play() {
    if (this.playing === false) {
      this.playing = true;
      this.createTimerStep(true);
    }
  }
  /**
   * Stop the entire group
   */
  stop() {
    if (this.playing === true) {
      this.playing = false;
      if (this.loopTimer) {
        clearTimeout(this.loopTimer);
      }
    }
  }
  /**
   * Set the MS value to 0
   */
  reset() {
    if (this.value !== 0) {
      this.value = 0;
      this.loopStep = 0;
    }
  }
};

// src/properties/analysis/group/AnalysisGroupGraph.ts
var AnalysisGroupGraph = class _AnalysisGroupGraph extends AbstractProperty {
  static LISTENER_ID = "AnalysisGroupGraph";
  constructor(parent) {
    super(parent, void 0);
  }
  timeout;
  calculateData() {
    let colors = [];
    let header = [];
    const data = [];
    const orderedFiles = this.parent.files.value.sort((a, b) => a.timestamp - b.timestamp);
    const firstRow = orderedFiles[0].analysisData.value.values[0];
    header = firstRow;
    colors = orderedFiles[0].analysisData.value.colors;
    this.parent.files.forEveryInstance((instance) => {
      const row = [
        new Date(instance.timestamp)
      ];
      instance.analysis.value.forEach(async (analysis) => {
        if (analysis.graph.state.MIN === true && analysis.min) {
          row.push(analysis.min);
        }
        if (analysis.graph.state.MAX === true && analysis.max) {
          row.push(analysis.max);
        }
        if (analysis.graph.state.AVG === true && analysis.avg) {
          row.push(analysis.avg);
        }
      });
      if (row.length > 1) {
        data.push(row);
      }
    });
    if (colors.length > 0) {
      this.value = {
        colors,
        data: [header, ...data]
      };
    } else {
      this.value = void 0;
    }
    console.log("P\u0159epo\u010D\xEDtal jsem data", this.value);
  }
  turnOn() {
    this.parent.files.forEveryInstance((instance) => {
      instance.analysisData.addListener(_AnalysisGroupGraph.LISTENER_ID, (value) => {
        if (this.timeout !== void 0) {
          clearTimeout(this.timeout);
        }
        this.timeout = setTimeout(() => {
          this.calculateData();
        }, 0);
      });
    });
  }
  turnOff() {
    this.parent.files.forEveryInstance((instance) => {
      instance.analysisData.removeListener(_AnalysisGroupGraph.LISTENER_ID);
    });
  }
  _wtf() {
    this.parent.files.forEveryInstance((instance) => {
      instance.analysis.layers.forEach((analysis) => {
        analysis.graph.setAvgActivation(true);
      });
    });
  }
  validate(value) {
    return value;
  }
  afterSetEffect(value) {
  }
};

// src/hierarchy/ThermalGroup.ts
var ThermalGroup = class extends BaseStructureObject {
  constructor(registry, id, name, description) {
    super();
    this.registry = registry;
    this.id = id;
    this.name = name;
    this.description = description;
  }
  hash = Math.random();
  /** Human readable label = name or id or hasn */
  get label() {
    return this.name ?? this.id ?? this.hash;
  }
  get pool() {
    return this.registry.manager.pool;
  }
  minmax = new MinmaxGroupProperty(this, void 0);
  /** Tool drive from above */
  get tool() {
    return this.registry.manager.tool;
  }
  files = new FilesState(this, []);
  cursorPosition = new CursorPositionDrive(this, void 0);
  analysisSync = new AnalysisSyncDrive(this, false);
  analysisGraph = new AnalysisGroupGraph(this);
  _playback;
  get playback() {
    if (!this._playback) {
      this._playback = new GroupPlayback(this, 0);
    }
    return this._playback;
  }
  /** Iteration */
  forEveryInstance = (fn) => {
    this.files.value.forEach((instance) => fn(instance));
  };
  /** Remove all instances, reset the minmax */
  destroySelfAndBelow() {
    this.removeAllChildren();
    this.minmax.reset();
  }
  removeAllChildren() {
    this.files.removeAllInstances();
  }
  reset() {
    this.files.reset();
    this.minmax.reset();
    this.cursorPosition.reset();
    this.analysisSync.reset();
  }
  filters = new FilterContainer(this);
  getInstances() {
    return this.files.value;
  }
  startBatch(id) {
    return this.registry.batch.getBatchById(id);
  }
};

// src/hierarchy/ThermalManager.ts
import * as workerpool from "workerpool";

// src/loading/workers/ThermalFileFailure.ts
var ThermalFileFailure = class _ThermalFileFailure extends AbstractFileResult {
  constructor(thermalUrl, code, message) {
    super(thermalUrl);
    this.code = code;
    this.message = message;
  }
  isSuccess() {
    return false;
  }
  static fromError(error) {
    return new _ThermalFileFailure(error.url, error.code, error.message);
  }
};

// src/loading/workers/errors.ts
var FileLoadingError = class extends Error {
  constructor(code, url, message) {
    super(message);
    this.code = code;
    this.url = url;
  }
};

// src/loading/workers/parsers/lrc/jobs/baseInfo.ts
var baseInfo = async (entireFileBuffer) => {
  const view = new DataView(entireFileBuffer);
  const width = view.getUint16(17, true);
  const height = view.getUint16(19, true);
  const bytesize = entireFileBuffer.byteLength;
  const readTimestamp = (readingView, index) => {
    const bigIntTime = readingView.getBigInt64(index, true);
    const UnixEpoch = 62135596800000n;
    const TicksPerMillisecond = 10000n;
    const TicksPerDay = 24n * 60n * 60n * 1000n * TicksPerMillisecond;
    const TicksCeiling = 0x4000000000000000n;
    const LocalMask = 0x8000000000000000n;
    const TicksMask = 0x3fffffffffffffffn;
    let ticks = bigIntTime & TicksMask;
    const isLocalTime = bigIntTime & LocalMask;
    if (isLocalTime) {
      if (ticks > TicksCeiling - TicksPerDay) {
        ticks -= TicksCeiling;
      }
      if (ticks < 0) {
        ticks += TicksPerDay;
      }
    }
    const milliseconds = ticks / TicksPerMillisecond - UnixEpoch;
    return Number(milliseconds);
  };
  const dataType = view.getUint8(15);
  let pixelByteSize = 2;
  if (dataType === 1) pixelByteSize = 4;
  const frameHeaderByteSize = 57;
  const framePixelsSize = width * height * pixelByteSize;
  const frameSize = frameHeaderByteSize + framePixelsSize;
  const streamSubset = entireFileBuffer.slice(25);
  const frameCount = streamSubset.byteLength / frameSize;
  const readFrame = (index) => {
    const frameSubsetStart = index * frameSize;
    const frameSubsetEnd = frameSubsetStart + frameSize;
    const frameArrayBuffer = streamSubset.slice(frameSubsetStart, frameSubsetEnd);
    const frameView = new DataView(frameArrayBuffer);
    const min = frameView.getFloat32(8, true);
    const max = frameView.getFloat32(12, true);
    const timestamp = readTimestamp(frameView, 0);
    const emissivity = frameView.getFloat32(24, true);
    const reflectedKelvins = frameView.getFloat32(28, true);
    return {
      timestamp,
      min,
      max,
      emissivity,
      reflectedKelvins
    };
  };
  const frames = [];
  for (let i = 0; i < frameCount; i++) {
    const frame = readFrame(i);
    frames.push(frame);
  }
  const sums = {
    emissivity: 0,
    reflectedKelvins: 0
  };
  let currentMin = Infinity;
  let currentMax = -Infinity;
  const timestamps = [];
  frames.forEach((frame) => {
    sums.emissivity = sums.emissivity + frame.emissivity;
    sums.reflectedKelvins = sums.reflectedKelvins + frame.reflectedKelvins;
    if (frame.min < currentMin) {
      currentMin = frame.min;
    }
    if (frame.max > currentMax) {
      currentMax = frame.max;
    }
    timestamps.push(frame.timestamp);
  });
  const timelineStart = timestamps[0];
  let timelineCursor = 0;
  const timeline = [];
  const f = [];
  timestamps.forEach((t, index) => {
    const next = timestamps[index + 1];
    let offset = 0;
    if (next === void 0) {
      offset = 0;
    }
    offset = next - t;
    const relative = t - timelineStart;
    timeline.push(offset);
    timelineCursor = timelineCursor + offset;
    f.push({
      absolute: t,
      relative,
      // isNaN( relativeTime ) ? 0 : relativeTime,
      offset: isNaN(offset) ? 0 : offset,
      index
    });
  });
  const duration = frames[frames.length - 1].timestamp - frames[0].timestamp;
  const frameInterval = duration / frameCount;
  const fps = 1e3 / frameInterval;
  const firstTimestamp = frames[0].timestamp;
  return {
    width,
    height,
    timestamp: firstTimestamp,
    bytesize,
    frameCount,
    duration,
    frameInterval,
    fps,
    timeline: f,
    min: currentMin,
    max: currentMax,
    averageEmissivity: sums.emissivity / frames.length,
    averageReflectedKelvins: sums.reflectedKelvins / frames.length
  };
};

// src/loading/workers/parsers/lrc/jobs/getFrameSubset.ts
var getFrameSubset = (entireFileBuffer, index) => {
  const headerView = new DataView(entireFileBuffer.slice(0, 25));
  const dataType = headerView.getUint8(15);
  const width = headerView.getUint16(17, true);
  const height = headerView.getUint16(19, true);
  const pixelByteSize = dataType === 1 ? 4 : 2;
  const frameHeaderSize = 57;
  const framePixelsSize = width * height * pixelByteSize;
  const frameSize = frameHeaderSize + framePixelsSize;
  const streamSubset = entireFileBuffer.slice(25);
  const frameSubsetStart = index * frameSize;
  const frameSubsetEnd = frameSubsetStart + frameSize;
  const frameSubset = streamSubset.slice(frameSubsetStart, frameSubsetEnd);
  return {
    array: frameSubset,
    dataType
  };
};
var frameData = async (frameSubset, dataType) => {
  const view = new DataView(frameSubset);
  const bigIntTime = view.getBigInt64(0, true);
  const UnixEpoch = 62135596800000n;
  const TicksPerMillisecond = 10000n;
  const TicksPerDay = 24n * 60n * 60n * 1000n * TicksPerMillisecond;
  const TicksCeiling = 0x4000000000000000n;
  const LocalMask = 0x8000000000000000n;
  const TicksMask = 0x3fffffffffffffffn;
  let ticks = bigIntTime & TicksMask;
  const isLocalTime = bigIntTime & LocalMask;
  if (isLocalTime) {
    if (ticks > TicksCeiling - TicksPerDay) {
      ticks -= TicksCeiling;
    }
    if (ticks < 0) {
      ticks += TicksPerDay;
    }
  }
  const milliseconds = ticks / TicksPerMillisecond - UnixEpoch;
  const timestamp = Number(milliseconds);
  const min = view.getFloat32(8, true);
  const max = view.getFloat32(12, true);
  const emissivity = view.getFloat32(24, true);
  const reflectedKelvins = view.getFloat32(28, true);
  const subset = frameSubset.slice(57);
  let pixels = [];
  if (dataType === 0) {
    const array = new Uint16Array(subset);
    const distance = Math.abs(min - max);
    const UINT16_MAX = 65535;
    array.forEach((pixel) => {
      const mappedValue = pixel / UINT16_MAX;
      pixels.push(min + distance * mappedValue);
    });
  } else if (dataType === 1) {
    pixels = Array.from(new Float32Array(subset));
  }
  return {
    timestamp,
    min,
    max,
    emissivity,
    reflectedKelvins,
    pixels
  };
};

// src/loading/workers/parsers/lrc/jobs/pointAnalysisData.ts
var pointAnalysisData = async (entireFileBuffer, x, y) => {
  const view = new DataView(entireFileBuffer);
  const width = view.getUint16(17, true);
  const height = view.getUint16(19, true);
  const readTimestamp = (readingView, index) => {
    const bigIntTime = readingView.getBigInt64(index, true);
    const UnixEpoch = 62135596800000n;
    const TicksPerMillisecond = 10000n;
    const TicksPerDay = 24n * 60n * 60n * 1000n * TicksPerMillisecond;
    const TicksCeiling = 0x4000000000000000n;
    const LocalMask = 0x8000000000000000n;
    const TicksMask = 0x3fffffffffffffffn;
    let ticks = bigIntTime & TicksMask;
    const isLocalTime = bigIntTime & LocalMask;
    if (isLocalTime) {
      if (ticks > TicksCeiling - TicksPerDay) {
        ticks -= TicksCeiling;
      }
      if (ticks < 0) {
        ticks += TicksPerDay;
      }
    }
    const milliseconds = ticks / TicksPerMillisecond - UnixEpoch;
    return Number(milliseconds);
  };
  const dataType = view.getUint8(15);
  let pixelByteSize = 2;
  if (dataType === 1) pixelByteSize = 4;
  const frameHeaderByteSize = 57;
  const framePixelsSize = width * height * pixelByteSize;
  const frameSize = frameHeaderByteSize + framePixelsSize;
  const streamSubset = entireFileBuffer.slice(25);
  const frameCount = streamSubset.byteLength / frameSize;
  const output = {};
  const readFrame = (index) => {
    const frameSubsetStart = index * frameSize;
    const frameSubsetEnd = frameSubsetStart + frameSize;
    const frameArrayBuffer = streamSubset.slice(frameSubsetStart, frameSubsetEnd);
    const frameView = new DataView(frameArrayBuffer);
    const timestamp = readTimestamp(frameView, 0);
    const min = frameView.getFloat32(8, true);
    const max = frameView.getFloat32(12, true);
    const range = max - min;
    const frameHeaderByteSize2 = 57;
    const pointIndex = frameHeaderByteSize2 + y * pixelByteSize * width + x * pixelByteSize;
    let temperature = 0;
    if (dataType === 1) {
      temperature = frameView.getFloat32(pointIndex, true);
    } else if (dataType === 0) {
      const rawtemperature = frameView.getInt16(pointIndex, true);
      const UINT16_MAX = 65535;
      const mappedValue = rawtemperature / UINT16_MAX;
      temperature = min + range * mappedValue;
    }
    return {
      timestamp,
      temperature
    };
  };
  let firstTimestamp = 0;
  for (let i = 0; i < frameCount; i++) {
    const frame = readFrame(i);
    if (firstTimestamp === 0) {
      firstTimestamp = frame.timestamp;
    }
    output[frame.timestamp - firstTimestamp] = frame.temperature;
  }
  return output;
};

// src/loading/workers/parsers/lrc/jobs/rectAnalysisData.ts
var rectAnalysisData = async (entireFileBuffer, left, top, _width, _height) => {
  const view = new DataView(entireFileBuffer);
  const fileWidth = view.getUint16(17, true);
  const fileHeight = view.getUint16(19, true);
  const readTimestamp = (readingView, index) => {
    const bigIntTime = readingView.getBigInt64(index, true);
    const UnixEpoch = 62135596800000n;
    const TicksPerMillisecond = 10000n;
    const TicksPerDay = 24n * 60n * 60n * 1000n * TicksPerMillisecond;
    const TicksCeiling = 0x4000000000000000n;
    const LocalMask = 0x8000000000000000n;
    const TicksMask = 0x3fffffffffffffffn;
    let ticks = bigIntTime & TicksMask;
    const isLocalTime = bigIntTime & LocalMask;
    if (isLocalTime) {
      if (ticks > TicksCeiling - TicksPerDay) {
        ticks -= TicksCeiling;
      }
      if (ticks < 0) {
        ticks += TicksPerDay;
      }
    }
    const milliseconds = ticks / TicksPerMillisecond - UnixEpoch;
    return Number(milliseconds);
  };
  const dataType = view.getUint8(15);
  let pixelByteSize = 2;
  if (dataType === 1) pixelByteSize = 4;
  const frameHeaderByteSize = 57;
  const framePixelsSize = fileWidth * fileHeight * pixelByteSize;
  const frameSize = frameHeaderByteSize + framePixelsSize;
  const streamSubset = entireFileBuffer.slice(25);
  const frameCount = streamSubset.byteLength / frameSize;
  const output = {};
  const readFrame = (index) => {
    const frameSubsetStart = index * frameSize;
    const frameSubsetEnd = frameSubsetStart + frameSize;
    const frameArrayBuffer = streamSubset.slice(frameSubsetStart, frameSubsetEnd);
    const frameView = new DataView(frameArrayBuffer);
    const timestamp = readTimestamp(frameView, 0);
    const min = frameView.getFloat32(8, true);
    const max = frameView.getFloat32(12, true);
    const range = max - min;
    const frameHeaderByteSize2 = 57;
    const fromX = left;
    const toX = left + _width;
    const fromY = top;
    const toY = top + _height;
    let _min = Infinity;
    let _max = -Infinity;
    let count = 0;
    let sum = 0;
    for (let y = fromY; y <= toY; y++) {
      const rowOffset = y * fileWidth;
      for (let x = fromX; x <= toX; x++) {
        const pointIndex = frameHeaderByteSize2 + (rowOffset + x) * pixelByteSize;
        let value = NaN;
        if (dataType === 1) {
          value = frameView.getFloat32(pointIndex, true);
        } else {
          const valueRaw = frameView.getInt16(pointIndex, true);
          const UINT16_MAX = 65535;
          const mappedValue = valueRaw / UINT16_MAX;
          value = min + range * mappedValue;
        }
        if (value < _min) {
          _min = value;
        }
        if (value > _max) {
          _max = value;
        }
        sum += value;
        count++;
      }
    }
    const result = {
      min: _min,
      max: _max,
      avg: sum / count,
      count
    };
    return {
      timestamp,
      result
    };
  };
  let firstTimestamp = 0;
  for (let i = 0; i < frameCount; i++) {
    const frame = readFrame(i);
    if (firstTimestamp === 0) {
      firstTimestamp = frame.timestamp;
    }
    output[frame.timestamp - firstTimestamp] = frame.result;
  }
  return output;
};

// src/loading/workers/parsers/lrc/jobs/histogram.ts
var registryHistogram = async (files) => {
  let pixels = [];
  const readFile = async (file) => {
    const headerView = new DataView(file.slice(0, 25));
    const dataType = headerView.getUint8(15);
    const width = headerView.getUint16(17, true);
    const height = headerView.getUint16(19, true);
    const pixelByteSize = dataType === 1 ? 4 : 2;
    const frameHeaderSize = 57;
    const framePixelsSize = width * height * pixelByteSize;
    const frameSize = frameHeaderSize + framePixelsSize;
    const streamSubset = file.slice(25);
    const frameCount = streamSubset.byteLength / frameSize;
    let filePixels = [];
    for (let i = 0; i < frameCount; i++) {
      const frameStart = i * frameSize;
      const pixelsSubsetStart = frameStart + 57;
      const pixelsSubsetEnd = pixelsSubsetStart + framePixelsSize;
      const pixelsSubset = streamSubset.slice(pixelsSubsetStart, pixelsSubsetEnd);
      if (dataType === 0) {
      } else if (dataType === 1) {
        filePixels = filePixels.concat(Array.from(new Float32Array(pixelsSubset)));
      }
    }
    return filePixels;
  };
  const result = await Promise.all(files.map((file) => readFile(file)));
  result.forEach((fileResult) => {
    pixels = pixels.concat(fileResult);
  });
  pixels.sort((a, b) => {
    return a - b;
  });
  const min = pixels[0];
  const max = pixels[pixels.length - 1];
  const distance = Math.abs(min - max);
  const resolution = 200;
  const step = distance / resolution;
  const bars = [];
  let buf = [...pixels];
  for (let i = 0; i < resolution; i++) {
    const from = min + step * i;
    const to = from + step;
    const nextUpIndex = buf.findIndex((pixel) => pixel > to);
    const subs = buf.slice(0, nextUpIndex - 1);
    const count = subs.length;
    const percentage = count / pixels.length * 100;
    const bar = {
      from,
      to,
      count,
      percentage
    };
    bars.push(bar);
    buf = buf.slice(nextUpIndex);
  }
  const sortedByPercentage = [...bars].sort((a, b) => {
    return a.percentage - b.percentage;
  });
  const minPercent = sortedByPercentage[0].percentage;
  const maxPercent = sortedByPercentage[sortedByPercentage.length - 1].percentage;
  const percentDistance = Math.abs(minPercent - maxPercent);
  const final = bars.map((bar) => {
    return {
      ...bar,
      height: bar.percentage / percentDistance * 100
    };
  });
  return final;
};

// src/loading/workers/parsers/lrc/jobs/is.ts
var is = (data, url) => {
  const hasCorrectExtension = url.endsWith("lrc");
  const decoder = new TextDecoder();
  const hasCorrectSignature = decoder.decode(data.slice(0, 4)) === "LRC\0";
  return hasCorrectExtension && hasCorrectSignature;
};

// src/loading/workers/parsers/lrc/jobs/ellipsisAnalysisData.ts
var ellipsisAnalysisData = async (entireFileBuffer, left, top, _width, _height) => {
  const view = new DataView(entireFileBuffer);
  const fileWidth = view.getUint16(17, true);
  const fileHeight = view.getUint16(19, true);
  const readTimestamp = (readingView, index) => {
    const bigIntTime = readingView.getBigInt64(index, true);
    const UnixEpoch = 62135596800000n;
    const TicksPerMillisecond = 10000n;
    const TicksPerDay = 24n * 60n * 60n * 1000n * TicksPerMillisecond;
    const TicksCeiling = 0x4000000000000000n;
    const LocalMask = 0x8000000000000000n;
    const TicksMask = 0x3fffffffffffffffn;
    let ticks = bigIntTime & TicksMask;
    const isLocalTime = bigIntTime & LocalMask;
    if (isLocalTime) {
      if (ticks > TicksCeiling - TicksPerDay) {
        ticks -= TicksCeiling;
      }
      if (ticks < 0) {
        ticks += TicksPerDay;
      }
    }
    const milliseconds = ticks / TicksPerMillisecond - UnixEpoch;
    return Number(milliseconds);
  };
  const dataType = view.getUint8(15);
  let pixelByteSize = 2;
  if (dataType === 1) pixelByteSize = 4;
  const frameHeaderByteSize = 57;
  const framePixelsSize = fileWidth * fileHeight * pixelByteSize;
  const frameSize = frameHeaderByteSize + framePixelsSize;
  const streamSubset = entireFileBuffer.slice(25);
  const frameCount = streamSubset.byteLength / frameSize;
  const output = {};
  const isWithin = (x, y) => {
    const centerX = left + _width / 2;
    const centerY = top + _height / 2;
    const normalizedX = (x - centerX) / (_width / 2);
    const normalizedY = (y - centerY) / (_height / 2);
    return normalizedX * normalizedX + normalizedY * normalizedY <= 1;
  };
  const readFrame = (index) => {
    const frameSubsetStart = index * frameSize;
    const frameSubsetEnd = frameSubsetStart + frameSize;
    const frameArrayBuffer = streamSubset.slice(frameSubsetStart, frameSubsetEnd);
    const frameView = new DataView(frameArrayBuffer);
    const timestamp = readTimestamp(frameView, 0);
    const min = frameView.getFloat32(8, true);
    const max = frameView.getFloat32(12, true);
    const range = max - min;
    const frameHeaderByteSize2 = 57;
    const fromX = left;
    const toX = left + _width;
    const fromY = top;
    const toY = top + _height;
    let _min = Infinity;
    let _max = -Infinity;
    let count = 0;
    let sum = 0;
    for (let y = fromY; y <= toY; y++) {
      const rowOffset = y * fileWidth;
      for (let x = fromX; x <= toX; x++) {
        if (isWithin(x, y)) {
          const pointIndex = frameHeaderByteSize2 + (rowOffset + x) * pixelByteSize;
          let value = NaN;
          if (dataType === 1) {
            value = frameView.getFloat32(pointIndex, true);
          } else {
            const valueRaw = frameView.getInt16(pointIndex, true);
            const UINT16_MAX = 65535;
            const mappedValue = valueRaw / UINT16_MAX;
            value = min + range * mappedValue;
          }
          if (value < _min) {
            _min = value;
          }
          if (value > _max) {
            _max = value;
          }
          sum += value;
          count++;
        }
      }
    }
    const result = {
      min: _min,
      max: _max,
      avg: sum / count,
      count
    };
    return {
      timestamp,
      result
    };
  };
  let firstTimestamp = 0;
  for (let i = 0; i < frameCount; i++) {
    const frame = readFrame(i);
    if (firstTimestamp === 0) {
      firstTimestamp = frame.timestamp;
    }
    output[frame.timestamp - firstTimestamp] = frame.result;
  }
  return output;
};

// src/loading/workers/parsers/lrc/LrcParser.ts
var extensions = [{
  extension: "lrc",
  minme: "application/octet-stream"
}];
var parser = {
  name: "LabIR Recording (.lrc)",
  description: "Radiometric data developed by the Infrared Technologies research team at the University of West Bohemia in Pilsen (CZ)",
  devices: [
    {
      deviceName: "TIMI Edu Infrared Camera",
      deviceUrl: "https://edu.labir.cz",
      deviceDescription: "A thermal camera designed for school education.",
      manufacturer: "TIMI Creation, s.r.o.",
      manufacturerUrl: "https://timic.cz"
    },
    {
      deviceName: "Custom measurement systems by IRT UWB in Pilsen (CZ)",
      deviceUrl: "https://irt.zcu.cz",
      deviceDescription: "Specialised applications of IR diagnostics in the field of industry, research, medicine, security or education.",
      manufacturer: "IRT UWB in Pilsen (CZ)",
      manufacturerUrl: "https://irt.zcu.cz"
    }
  ],
  extensions,
  is,
  baseInfo,
  getFrameSubset,
  frameData,
  registryHistogram,
  pointAnalysisData,
  rectAnalysisData,
  ellipsisAnalysisData
};
var LrcParser = Object.freeze(parser);

// src/loading/workers/parsers/index.ts
var parsers = {
  LrcParser
};
var parsersArray = Object.values(parsers);
var determineParser = (buffer, url) => {
  const parser2 = parsersArray.find((parser3) => parser3.is(buffer, url));
  if (parser2 === void 0) {
    throw new FileLoadingError(2 /* MIME_UNSUPPORTED */, url, `No parser found for '${url}'.`);
  }
  return parser2;
};
var supportedFileTypes = parsersArray.map((parser2) => parser2.extensions);
var supportedFileTypesInputProperty = supportedFileTypes.map(
  (type) => type.map((entry) => entry.minme + ", ." + entry.extension).join(", ")
).join(", ");

// src/loading/workers/FileRequest.ts
var FileRequest = class _FileRequest {
  constructor(service, thermalUrl, visibleUrl) {
    this.service = service;
    this.thermalUrl = thermalUrl;
    this.visibleUrl = visibleUrl;
  }
  static fromUrl(service, thermalUrl, visibleUrl) {
    return new _FileRequest(service, thermalUrl, visibleUrl);
  }
  /**
   * The request is stored internally, so that multiple calls of `load` will allways result in one single `Promise` - to this one.
   */
  response;
  /**
   * Fetch a file, process the response and return the promise
   * - the promise is stored internally
   * - if the request is already loading/processing, any subsequent calls use the stored promise object
   */
  async load() {
    if (this.response === void 0) {
      this.response = this.processResponse(fetch(this.thermalUrl));
    }
    return this.response;
  }
  /** 
   * Process the raw response:
   * - decide if the file exists
   * - assign parser to the file
   * - create the service
   */
  async processResponse(response) {
    const res = await response;
    if (res.status !== 200) {
      return this.pocessTheService(
        new ThermalFileFailure(
          this.thermalUrl,
          1 /* FILE_NOT_FOUND */,
          `File '${this.thermalUrl}' was not found.`
        )
      );
    }
    const buffer = await res.arrayBuffer();
    try {
      const parser2 = determineParser(buffer, this.thermalUrl);
      return this.pocessTheService(
        new ThermalFileReader(
          this.service,
          buffer,
          parser2,
          this.thermalUrl,
          this.visibleUrl
        )
      );
    } catch (error) {
      if (error instanceof FileLoadingError) {
        return this.pocessTheService(
          ThermalFileFailure.fromError(error)
        );
      } else {
        throw error;
      }
    }
  }
  /**
   * Actions taken on the `AbstractFileResult` object
   * @todo because there are no side effects, this method might appear redundant
   */
  pocessTheService(result) {
    return result;
  }
};

// src/loading/workers/dropin/DropinElementManager.ts
var DropinElementListener = class _DropinElementListener {
  constructor(service, element) {
    this.service = service;
    this.element = element;
    this.bindedLeaveListener = this.handleLeave.bind(this);
    this.bindedEnterListener = this.handleEnter.bind(this);
    this.bindedDropListener = this.handleDrop.bind(this);
    this.bindedInputChangeListener = this.handleInputChange.bind(this);
    this.bindedDragoverListener = this.handleDragover.bind(this);
    this.bindedClickListener = this.handleClick.bind(this);
  }
  _hover = false;
  get hover() {
    return this._hover;
  }
  onMouseEnter = new CallbacksManager();
  onMouseLeave = new CallbacksManager();
  onDrop = new CallbacksManager();
  onProcessingEnd = new CallbacksManager();
  /** An invissible input element */
  input;
  hydrated = false;
  // Listeners are not added from the class, but binded
  // into the following properties
  bindedEnterListener;
  bindedLeaveListener;
  bindedDropListener;
  bindedInputChangeListener;
  bindedDragoverListener;
  bindedClickListener;
  static listenOnElement(service, element) {
    const listener = new _DropinElementListener(service, element);
    listener.hydrate();
    return listener;
  }
  /** Bind all event listeners to the provided element */
  hydrate() {
    if (this.hydrated === false) {
      this.hydrated = true;
      this.input = this.getInput();
      this.element.addEventListener("dragover", this.bindedDragoverListener);
      this.element.addEventListener("dragleave", this.bindedLeaveListener);
      this.element.addEventListener("dragend", this.bindedLeaveListener);
      this.element.addEventListener("pointerdown", this.bindedClickListener);
      this.element.addEventListener("drop", this.bindedDropListener);
      this.input.addEventListener("change", this.bindedInputChangeListener);
    }
  }
  /** Remove all event listeners from the element */
  dehydrate() {
    if (this.hydrated === true) {
      this.hydrated = false;
      if (this.input)
        this.input.remove();
      this.element.removeEventListener("dragover", this.bindedDragoverListener);
      this.element.removeEventListener("dragleave", this.bindedLeaveListener);
      this.element.removeEventListener("dragend", this.bindedLeaveListener);
      this.element.removeEventListener("pointerdown", this.bindedClickListener);
      this.element.removeEventListener("drop", this.bindedDropListener);
    }
  }
  handleClick(event) {
    event.preventDefault();
    if (this.input)
      this.input.click();
  }
  handleDragover(event) {
    event.preventDefault();
    this.handleEnter();
  }
  async handleDrop(event) {
    event.preventDefault();
    const results = [];
    const transfer = event.dataTransfer;
    if (transfer && transfer.files) {
      for (const file of Array.from(transfer.files)) {
        if (file) {
          const service = await this.service.loadUploadedFile(file);
          results.push(service);
        }
      }
    }
    console.log("drop >>>>>", results);
    this.onDrop.call(results);
    this.handleLeave();
    return results;
  }
  async handleInputChange(event) {
    event.preventDefault();
    const target = event.target;
    if (target.files) {
      const results = [];
      for (const file of Array.from(target.files)) {
        results.push(await this.service.loadUploadedFile(file));
      }
      console.log("input >>>>>", results);
      this.onDrop.call(results);
      this.handleLeave();
    }
  }
  handleEnter() {
    if (this._hover === false) {
      this._hover = true;
      this.onMouseEnter.call();
    }
  }
  handleLeave() {
    if (this._hover === true) {
      this._hover = false;
      this.onMouseLeave.call();
    }
  }
  /** Build the internal input */
  getInput() {
    const element = document.createElement("input");
    element.type = "file";
    element.accept = supportedFileTypesInputProperty;
    element.multiple = true;
    return element;
  }
  openFileDialog(multiple = true) {
    if (this.input !== void 0) {
      this.input.multiple = multiple;
      this.input.click();
    }
  }
};

// src/loading/workers/FilesService.ts
var FilesService = class {
  constructor(manager) {
    this.manager = manager;
  }
  get pool() {
    return this.manager.pool;
  }
  static isolatedInstance(pool4, registryName = "isolated_registry") {
    const manager = new ThermalManager(pool4);
    const registry = manager.addOrGetRegistry(registryName);
    return {
      service: registry.service,
      registry
    };
  }
  /** Map of peoding requesta */
  requestsByUrl = /* @__PURE__ */ new Map();
  /** Number of currently pending requests */
  get requestsCount() {
    return this.requestsByUrl.size;
  }
  /** Is an URL currently pending? */
  fileIsPending(url) {
    return this.requestsByUrl.has(url);
  }
  /** Cache of loaded files */
  cacheByUrl = /* @__PURE__ */ new Map();
  /** Number of cached results */
  get cachedServicesCount() {
    return this.cacheByUrl.size;
  }
  /** Is the URL already in the cache? */
  fileIsInCache(url) {
    return this.cacheByUrl.has(url);
  }
  /** Process a file obrained from anywhere */
  async loadUploadedFile(file) {
    try {
      const buffer = await file.arrayBuffer();
      const parser2 = determineParser(buffer, file.name);
      return new ThermalFileReader(this, buffer, parser2, file.name);
    } catch (error) {
      return new ThermalFileFailure(
        file.name,
        3 /* PARSING_ERROR */,
        error.message
      );
    }
  }
  /** Create a dropzone listener on a HTML element */
  handleDropzone(element) {
    return DropinElementListener.listenOnElement(this, element);
  }
  /** Load a file from URL, eventually using already cached result */
  async loadFile(thermalUrl, visibleUrl) {
    if (this.cacheByUrl.has(thermalUrl)) {
      return this.cacheByUrl.get(thermalUrl);
    } else if (this.requestsByUrl.has(thermalUrl)) {
      return this.requestsByUrl.get(thermalUrl).load();
    } else {
      const request = FileRequest.fromUrl(this, thermalUrl, visibleUrl);
      this.requestsByUrl.set(thermalUrl, request);
      const result = await request.load();
      this.requestsByUrl.delete(thermalUrl);
      this.cacheByUrl.set(thermalUrl, result);
      return result;
    }
  }
};

// src/properties/display/GraphSmoothDrive.ts
var GraphSmoothDrive = class extends AbstractProperty {
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  setGraphSmooth(value) {
    this.value = value;
  }
};

// src/properties/scale/PaletteDrive.ts
var PaletteDrive = class extends AbstractProperty {
  get availablePalettes() {
    return ThermalPalettes;
  }
  /** All the current palette properties should be accessed through this property. */
  get currentPalette() {
    return this.availablePalettes[this.value];
  }
  /** @deprecated Should not be used at all. Use `currentPalette` instead */
  get currentPixels() {
    return this.currentPalette.pixels;
  }
  validate(value) {
    return value;
  }
  /** Any changes to the value should propagate directly to every instance. */
  afterSetEffect(value) {
    this.parent.forEveryRegistry((registry) => {
      registry.forEveryInstance((instance) => instance.recievePalette(value));
    });
  }
  setPalette(key) {
    this.value = key;
  }
};

// src/properties/display/SmoothDrive.ts
var SmoothDrive = class extends AbstractProperty {
  validate(value) {
    return value;
  }
  afterSetEffect(value) {
    this.parent.forEveryRegistry((registry) => registry.forEveryInstance((instance) => {
      instance.canvasLayer.canvas.style.imageRendering = value === true ? "auto" : "pixelated";
    }));
  }
  setSmooth(value) {
    this.value = value;
  }
};

// src/loading/batch/Batch.ts
var Batch = class _Batch {
  constructor(loader, id) {
    this.loader = loader;
    this.id = id;
  }
  _loading = false;
  get loading() {
    return this._loading;
  }
  onResolve = new CallbacksManager();
  /** The current timeout fn that is being overriden by every call of the `request` method */
  timeout = void 0;
  /** Array of currently queued requests */
  queue = [];
  get size() {
    return this.queue.length;
  }
  static init(loader, id) {
    return new _Batch(loader, id);
  }
  static initWithRequest(loader, thermalUrl, visibleUrl = void 0, group, callback) {
    const item = new _Batch(loader);
    item.request(thermalUrl, visibleUrl, group, callback);
    return item;
  }
  /**
   * Request a thermal file
   * 
   * Requesting adds new record to the queue and creates a new
   * timeout closure.
   */
  request(thermalUrl, visibleUrl, group, callback) {
    this.queue.push({
      thermalUrl,
      visibleUrl,
      group,
      callback
    });
    if (this.timeout !== void 0) {
      clearTimeout(this.timeout);
    }
    this.timeout = setTimeout(async () => {
      this._loading = true;
      const loadedReaders = await Promise.all(this.queue.map(async (item) => {
        return {
          result: await this.loader.registry.service.loadFile(item.thermalUrl, item.visibleUrl),
          callback: item.callback,
          group: item.group
        };
      }));
      const createdInstances = await Promise.all(loadedReaders.map(async (result) => {
        const item = result.result instanceof ThermalFileReader ? await result.result.createInstance(result.group) : await result.result;
        return {
          result: item,
          callback: result.callback
        };
      }));
      this.loader.registry.postLoadedProcessing();
      const results = await Promise.all(createdInstances.map(async (result) => {
        await result.callback(result.result);
        return result.result;
      }));
      this.loader.onBatchComplete.call(results);
      this.loader.batchFinished(this);
      this.onResolve.call(results);
    }, 0);
  }
  close() {
    this._loading = true;
  }
};

// src/loading/batch/BatchLoader.ts
var BatchLoader = class {
  constructor(registry) {
    this.registry = registry;
  }
  onBatchComplete = new CallbacksManager();
  set = /* @__PURE__ */ new Set();
  get numberOfBatches() {
    return this.set.size;
  }
  get currentOpenBatch() {
    return Array.from(this.set).find((batch) => batch.loading === false);
  }
  get hasLoadingBatches() {
    return Array.from(this.set).some((batch) => batch.loading === true);
  }
  get numLoadingBatches() {
    return Array.from(this.set).filter((batch) => batch.loading === true).length;
  }
  getBatchById(id) {
    const found = Array.from(this.set).find((batch) => batch.id === id);
    if (found) {
      return found;
    }
    const item = Batch.init(this, id);
    this.set.add(item);
    return item;
  }
  /**
   * Request a file through a batch
   * 
   * If there is an open batch, register the request in it. 
   * Else open a new batch.
   * 
   * The batch will execute automatically in the next tick.
   */
  request(thermalUrl, visibleUrl, group, callback, id) {
    let openBatch = id ? this.getBatchById(id) : this.currentOpenBatch;
    if (openBatch === void 0) {
      openBatch = Batch.init(this);
      this.set.add(openBatch);
      this.registry.loading.markAsLoading();
    }
    openBatch.request(
      thermalUrl,
      visibleUrl,
      group,
      callback
    );
    return openBatch;
  }
  closeBatch() {
    if (this.currentOpenBatch !== void 0) {
      this.currentOpenBatch.close();
    }
  }
  /**
   * This method is called from the inside of a batch object
   * to indicate its completion. 
   * 
   * Upon completion, the batch object is deleted and if there 
   * are no other batches, mark the registry as loaded.
   */
  batchFinished(batch) {
    this.set.delete(batch);
    if (this.numberOfBatches === 0) {
      this.registry.loading.markAsLoaded();
    }
  }
};

// src/properties/display/OpacityDrive.ts
var OpacityDrive = class extends AbstractProperty {
  /** Make sure the value is allways between 0 and 1 */
  validate(value) {
    return Math.min(Math.max(0, value), 1);
  }
  /** 
   * Whenever the opacity changes, propagate the value to all instances
   */
  afterSetEffect(value) {
    this.parent.forEveryInstance((instance) => instance.recieveOpacity(value));
  }
  /** Impose an opacity to all instances */
  imposeOpacity(value) {
    this.value = value;
    return this.value;
  }
};

// src/properties/scale/RangeDriver.ts
var RangeDriver = class extends AbstractProperty {
  get currentRange() {
    return this.value;
  }
  /** 
   * Make sure the range is allways within the minmax values.
   * 
   * If this method should work, the value needs to be set before the minmax is calculated.
   */
  validate(value) {
    if (value === void 0) {
      return void 0;
    }
    const minmax = this.parent.minmax.value;
    if (minmax === void 0) {
      return value;
    }
    const result = { ...value };
    if (value.from < minmax.min)
      result.from = minmax.min;
    if (value.to > minmax.max)
      result.to = minmax.max;
    return result;
  }
  /**
   * Whenever the range changes, propagate the value to all instances
   */
  afterSetEffect(value) {
    if (value)
      this.parent.forEveryInstance((instance) => instance.recieveRange(value));
  }
  /** 
   * Imposes a range to itself and below
   * - needs to be called before the minmax is calculated!
   */
  imposeRange(value) {
    if (value === void 0 && this.value === void 0) {
    } else if (value === void 0 && this.value !== void 0) {
      this.value = value;
    }
    if (value !== void 0 && this.value === void 0) {
      this.value = value;
    } else if (value !== void 0 && this.value !== void 0) {
      if (this.value.from !== value.from || this.value.to !== value.to) {
        this.value = value;
      }
    }
    return this.value;
  }
  /** Sets the range to the current minmax values */
  applyMinmax() {
    if (this.parent.minmax.value) {
      const newRange = { from: this.parent.minmax.value.min, to: this.parent.minmax.value.max };
      this.imposeRange(newRange);
    }
  }
  /** Sets the range automatically based on the current histogram */
  applyAuto() {
    if (this.parent.histogram.value) {
      const length = this.parent.histogram.value.length;
      const percentage = 100 / length;
      const histogramBarsOverPercentage = this.parent.histogram.value.filter((bar) => bar.height >= percentage);
      const newRange = {
        from: histogramBarsOverPercentage[0].from,
        to: histogramBarsOverPercentage[histogramBarsOverPercentage.length - 1].to
      };
      this.imposeRange(newRange);
    }
  }
};

// src/properties/lists/GroupsState.ts
var GroupsState = class extends AbstractProperty {
  _map = /* @__PURE__ */ new Map();
  get map() {
    return this._map;
  }
  validate(value) {
    return value;
  }
  afterSetEffect(value) {
    this._map.clear();
    value.forEach((group) => this._map.set(group.id, group));
  }
  addExistingGroup(group) {
    if (!this.value.map((g) => g.hash).includes(group.hash)) {
      this.value = [...this.value, group];
    }
  }
  addOrGetGroup(groupId, name, description) {
    if (this._map.has(groupId)) {
      return this._map.get(groupId);
    }
    const group = new ThermalGroup(this.parent, groupId, name, description);
    this._map.set(groupId, group);
    this.value.push(group);
    this.value = [...this.value];
    return group;
  }
  removeGroup(groupId) {
    if (!this._map.has(groupId)) {
      return;
    }
    this._map.get(groupId)?.destroySelfAndBelow();
    this._map.delete(groupId);
    this.value = Array.from(this._map.values());
  }
  removeAllGroups() {
    this.value.forEach((group) => group.destroySelfAndBelow());
    this.value = [];
  }
};

// src/properties/states/HistogramState.ts
var HistogramState = class extends AbstractProperty {
  _resolution = 150;
  get resolution() {
    return this._resolution;
  }
  /** Map of temperature => countOfPixels in the scaled down resolution @deprecated */
  buffer = /* @__PURE__ */ new Map();
  /** Total countOfPixels in every image @deprecated */
  bufferPixelsCount = 0;
  /** @deprecated */
  _bufferResolution = 1e3;
  set bufferResolution(value) {
    this._bufferResolution = Math.round(Math.max(value, 1e3));
  }
  get bufferResolution() {
    return this._bufferResolution;
  }
  /** Set the historgam resolution
   * - does not recalculate the value!
   * - to recalculate value, call `recalculateWithCurrentSetting`
   * 
   * @notice Higher the number, lower the resolution.
   * @deprecated Resolution is calculated in a separate thread, no resolution changes allowed
  */
  setResolution(value) {
    this._resolution = Math.round(Math.min(Math.max(value, 2), 1e3));
  }
  /** If incorrect resolution is being set, set empty array @todo there may be an error in +1*/
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  /** Recalculates the value using all current instances and with che current resolution @deprecated should not recalculate the histogram on the fly*/
  recalculateWithCurrentSetting() {
    this.recalculateHistogram();
    return this.value;
  }
  /** 
   * Recalculate the histogram buffer using web workers.
   * This is an async operation using `workerpool`
   */
  recalculateHistogramBufferInWorker() {
    if (this.parent.minmax.value !== void 0 && this.parent.groups.value.length !== 0 && this.parent.minmax.distanceInCelsius !== void 0) {
      const pixels = this.parent.groups.value.map((group) => {
        return group.files.value.map((instance) => instance.getPixelsForHistogram());
      });
      this.parent.pool.exec((instancesPixels, min, max, distance, resolution) => {
        const mergedPixels = instancesPixels.reduce((state, current) => {
          const inner = current.reduce((state2, current2) => {
            return [...state2, ...current2];
          }, []);
          return [...state, ...inner];
        }, []);
        let sortedPixels = mergedPixels.sort((a, b) => a - b);
        const step = distance / resolution;
        let nextStep = min + step;
        const result = /* @__PURE__ */ new Map();
        let resultCount = 0;
        while (nextStep !== false) {
          const nextIndex = sortedPixels.findIndex((num) => num > nextStep);
          const pixelCount = sortedPixels.slice(0, nextIndex).length;
          result.set(nextStep - step / 2, pixelCount);
          resultCount += pixelCount;
          sortedPixels = sortedPixels.slice(nextIndex);
          const nextStepTemporary = nextStep + step;
          nextStep = nextStepTemporary < max ? nextStepTemporary : false;
        }
        return {
          result,
          resultCount
        };
      }, [
        pixels,
        this.parent.minmax.value.min,
        this.parent.minmax.value.max,
        this.parent.minmax.distanceInCelsius,
        this._bufferResolution
      ]).then((result) => {
        this.buffer = result.result;
        this.bufferPixelsCount = result.resultCount;
        this.recalculateWithCurrentSetting();
      });
    }
  }
  async recalculateHistogram() {
    const allFiles = this.parent.groups.value.map((group) => group.files.value).reduce((state, current) => {
      state = state.concat(current);
      return state;
    }, []);
    const allBuffers = allFiles.map((reader) => reader.reader.buffer);
    const result = await this.parent.pool.exec(LrcParser.registryHistogram, [allBuffers]);
    this.value = result;
  }
};

// src/properties/states/LoadingState.ts
var LoadingState = class extends AbstractProperty {
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  markAsLoading() {
    if (this.value === false) {
      this.value = true;
    }
  }
  markAsLoaded() {
    if (this.value === true) {
      this.value = false;
    }
  }
};

// src/properties/scale/MinmaxRegistryState.ts
var MinmaxRegistryProperty = class extends AbstractMinmaxProperty {
  validate(value) {
    return value;
  }
  afterSetEffect() {
  }
  recalculateFromGroups() {
    const groups = this.parent.groups.value;
    this.value = this._getMinmaxFromAllGroups(groups);
    return this.value;
  }
  _getMinmaxFromAllGroups(groups) {
    if (groups.length === 0) {
      return void 0;
    }
    const minmax = groups.reduce((state, current) => {
      if (current.minmax.value === void 0) {
        return state;
      }
      return {
        min: current.minmax.value.min < state.min ? current.minmax.value.min : state.min,
        max: current.minmax.value.max > state.max ? current.minmax.value.max : state.max
      };
    }, { min: Infinity, max: -Infinity });
    return minmax;
  }
};

// src/hierarchy/ThermalRegistry.ts
var ThermalRegistry = class extends BaseStructureObject {
  constructor(id, manager, options) {
    super();
    this.id = id;
    this.manager = manager;
    this.palette = this.manager.palette;
    if (options) {
      if (options.histogramResolution !== void 0) {
        if (options.histogramResolution > 0)
          this.histogram.setResolution(options.histogramResolution);
      }
    }
  }
  hash = Math.random();
  /** Service */
  get service() {
    return this.manager.service;
  }
  get pool() {
    return this.manager.pool;
  }
  /** Groups are stored in an observable property */
  groups = new GroupsState(this, []);
  /** Iterator methods */
  forEveryGroup(fn) {
    this.groups.value.forEach(fn);
  }
  forEveryInstance(fn) {
    this.forEveryGroup((group) => group.files.forEveryInstance(fn));
  }
  /** Full load of the registry with multiple files @deprecated */
  async loadFullMultipleFiles(files) {
    this.reset();
    this.loading.markAsLoading();
    const servicesByGroup = await Promise.all(Object.entries(files).map(async ([groupId, fs]) => {
      const group = this.groups.addOrGetGroup(groupId);
      const groupFiles = await Promise.all(fs.map((file) => {
        return this.service.loadFile(file.thermalUrl, file.visibleUrl);
      }));
      return {
        group,
        groupFiles
      };
    }));
    const result = await Promise.all(servicesByGroup.map(async ({ group, groupFiles }) => {
      const instances = await Promise.all(groupFiles.map(async (service) => {
        if (service instanceof ThermalFileReader) {
          return await service.createInstance(group);
        } else {
          return false;
        }
      }));
      return instances;
    }));
    this.postLoadedProcessing();
    return result;
  }
  /** Load the registry with only one file. @deprecated */
  async loadFullOneFile(file, groupId) {
    this.reset();
    this.loading.markAsLoading();
    const group = this.groups.addOrGetGroup(groupId);
    const result = await this.service.loadFile(file.thermalUrl, file.visibleUrl);
    const instanceOrError = result instanceof ThermalFileReader ? await result.createInstance(group) : result;
    this.loading.markAsLoaded();
    this.postLoadedProcessing();
    return instanceOrError;
  }
  _batch;
  get batch() {
    if (!this._batch) this._batch = new BatchLoader(this);
    return this._batch;
  }
  /** @deprecated use batch member class instead */
  registerRequest(thermalUrl, visibleUrl = void 0, group, callback) {
    this.batch.request(thermalUrl, visibleUrl, group, callback);
  }
  onProcessingStart = new CallbacksManager();
  onProcessingEnd = new CallbacksManager();
  /** 
   * Actions to take after the registry is loaded 
   * - recalculate the minmax of groups
   * - recalculate minmax of registry
   * - impose new minmax as new range
   * - recalculate the histogram
  */
  async postLoadedProcessing() {
    this.onProcessingStart.call();
    this.forEveryGroup((group) => group.minmax.recalculateFromInstances());
    this.minmax.recalculateFromGroups();
    if (this.minmax.value)
      if (this.range.value === void 0) {
        this.range.imposeRange({ from: this.minmax.value.min, to: this.minmax.value.max });
      } else {
        const newFrom = Math.max(this.range.value.from, this.minmax.value.min);
        const newTo = Math.min(this.range.value.to, this.minmax.value.max);
        if (newFrom !== this.range.value.from || newTo !== this.range.value.to) {
          this.range.imposeRange({
            from: Math.max(this.range.value.from, this.minmax.value.min),
            to: Math.min(this.range.value.to, this.minmax.value.max)
          });
        }
      }
    this.histogram.recalculateHistogramBufferInWorker();
    this.loading.markAsLoaded();
    this.onProcessingEnd.call();
  }
  reset() {
    this.groups.removeAllGroups();
    this.opacity.reset();
    this.minmax.reset();
  }
  removeAllChildren() {
    this.groups.removeAllGroups();
  }
  destroySelfAndBelow() {
    this.reset();
  }
  destroySelfInTheManager() {
    this.manager.removeRegistry(this.id);
  }
  /**
   * Observable properties and drives
   */
  /** 
   * Opacity property 
   */
  opacity = new OpacityDrive(this, 1);
  /** 
   * Minmax property 
   */
  minmax = new MinmaxRegistryProperty(this, void 0);
  /**
   * Loading
   */
  loading = new LoadingState(this, false);
  /**
   * Range
   */
  range = new RangeDriver(this, void 0);
  /**
   * Histogram
   */
  histogram = new HistogramState(this, []);
  /**
   * Palette
   */
  palette;
  filters = new FilterContainer(this);
  getInstances() {
    let instances = [];
    this.groups.value.forEach((group) => {
      instances = [
        ...instances,
        ...group.getInstances()
      ];
    });
    return instances;
  }
};

// src/properties/analysis/tool/internals/AbstractTool.ts
var AbstractTool = class {
  constructor(manager) {
    this.manager = manager;
  }
  active = false;
  /** Action taken upon tool activation */
  activate() {
    this.onActivate();
  }
  /** Actions taken upon tool deactivation */
  deactivate() {
    this.onDeactivate();
  }
};

// src/properties/analysis/analysis/internals/AbstractAddTool.ts
var AbstractAddTool = class extends AbstractTool {
};

// src/properties/analysis/analysis/internals/area/ellipsis/AddEllipsisTool.ts
var AddEllipsisTool = class extends AbstractAddTool {
  key = "add-ellipsis";
  name = "addellipsisanalysis";
  description = "clickandaddellipsis";
  icon = `<?xml version="1.0" encoding="UTF-8"?>
<svg class="thermal-tool-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  <path fill="currentcolor" d="M48.87,21.96C47.6,9.62,37.17,0,24.5,0,10.97,0,0,10.97,0,24.5h0c0,12.67,9.62,23.1,21.96,24.37,2.71,8.76,10.88,15.13,20.54,15.13,11.87,0,21.5-9.63,21.5-21.5,0-9.66-6.37-17.82-15.13-20.54ZM4,24.5C4,13.2,13.2,4,24.5,4c10.15,0,18.57,7.42,20.2,17.11-.72-.07-1.45-.11-2.2-.11-11.87,0-21.5,9.63-21.5,21.5,0,.74.04,1.47.11,2.2-9.69-1.62-17.11-10.05-17.11-20.2ZM55.23,44.5h-10.65v10.65h-4v-10.65h-10.65v-4h10.65v-10.65h4v10.65h10.65v4Z"/>
</svg>`;
  onActivate() {
    this.manager.forEveryInstance((instance) => {
      instance.analysis.layers.selectedOnly.forEach((analysis) => {
        analysis.setDeselected();
      });
    });
  }
  onDeactivate() {
  }
  onCanvasLeave() {
  }
  onCanvasClick(top, left, file) {
    const newRect = file.analysis.layers.createEllipsisFrom(top, left);
    newRect.setSelected(true);
  }
  onPointDown() {
  }
  onPointUp(point) {
    if (!point.isInSelectedLayer()) {
      return;
    }
    point.deactivate();
    point.analysis.file.group.tool.selectTool("edit");
    point.analysis.ready = true;
    if (point.analysis.width <= 0 || point.analysis.height <= 0) {
      point.analysis.layers.removeAnalysis(point.analysis.key);
    } else {
      if (point.analysis.file.slots.value.size <= AnalysisSlotsState.MAX_SLOTS) {
        const slot = point.analysis.file.slots.getNextFreeSlotNumber();
        if (slot !== void 0) {
          point.file.slots.assignSlot(slot, point.analysis);
        }
      }
    }
  }
  onPointMove(point, top, left) {
    if (point.isInSelectedLayer() && point.active) {
      point.setXFromTool(left);
      point.setYFromTool(top);
      point.analysis.onMoveOrResize.call(point.analysis);
    }
  }
  onPointLeave() {
  }
  onPointEnter() {
  }
  getLabelValue = (x, y, file) => {
    const temperature = file.group.tool.tools.inspect.getLabelValue(x, y, file);
    return `X:${x}<br />Y:${y}<br />${temperature}`;
  };
};

// src/properties/analysis/analysis/internals/area/rectangle/AddRectangleTool.ts
var AddRectangleTool = class extends AbstractAddTool {
  key = "add-rect";
  name = "addrectangleanalysis";
  description = "clickandaddrectangle";
  icon = `<?xml version="1.0" encoding="UTF-8"?>
<svg class="thermal-tool-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  <path d="M49,22.01V0H0v49h22.01c2.76,8.7,10.89,15,20.49,15,11.87,0,21.5-9.63,21.5-21.5,0-9.61-6.3-17.74-15-20.49ZM4,45V4h41v17.16c-.82-.1-1.65-.16-2.5-.16-11.87,0-21.5,9.63-21.5,21.5,0,.85.06,1.68.16,2.5H4ZM55.23,44.5h-10.65v10.65h-4v-10.65h-10.65v-4h10.65v-10.65h4v10.65h10.65v4Z" fill="currentcolor"/>
</svg>`;
  onActivate() {
    this.manager.forEveryInstance((instance) => {
      instance.analysis.layers.selectedOnly.forEach((analysis) => {
        analysis.setDeselected();
      });
    });
  }
  onDeactivate() {
  }
  onCanvasLeave() {
  }
  onCanvasClick(x, y, file) {
    const newRect = file.analysis.layers.createRectFrom(x, y);
    newRect.setSelected(true);
  }
  onPointDown() {
  }
  onPointUp(point) {
    if (!point.isInSelectedLayer()) {
      return;
    }
    point.deactivate();
    point.analysis.file.group.tool.selectTool("edit");
    point.analysis.ready = true;
    if (point.analysis.width <= 0 || point.analysis.height <= 0) {
      point.analysis.layers.removeAnalysis(point.analysis.key);
    } else {
      const slot = point.analysis.file.slots.getNextFreeSlotNumber();
      if (slot !== void 0) {
        point.file.slots.assignSlot(slot, point.analysis);
      }
    }
  }
  onPointMove(point, top, left) {
    if (point.isInSelectedLayer() && point.active) {
      point.setXFromTool(left);
      point.setYFromTool(top);
      point.analysis.onMoveOrResize.call(point.analysis);
    }
  }
  onPointLeave() {
  }
  onPointEnter() {
  }
  getLabelValue = (x, y, file) => {
    const temperature = file.group.tool.tools.inspect.getLabelValue(x, y, file);
    return `X:${x}<br />Y:${y}<br />${temperature}`;
  };
};

// src/properties/analysis/analysis/internals/point/AddPointTool.ts
var AddPointTool = class extends AbstractAddTool {
  key = "add-point";
  name = "addpointanalysis";
  description = "clickandaddpoint";
  icon = `<?xml version="1.0" encoding="UTF-8"?>
<svg class="thermal-tool-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  <path fill="currentcolor" d="M34,19h-15v15h-4v-15H0v-4h15V0h4v15h15v4ZM64,42.5c0,11.87-9.63,21.5-21.5,21.5s-21.5-9.63-21.5-21.5,9.63-21.5,21.5-21.5,21.5,9.63,21.5,21.5ZM55.23,40.5h-10.65v-10.65h-4v10.65h-10.65v4h10.65v10.65h4v-10.65h10.65v-4Z"/>
</svg>`;
  onActivate() {
    this.manager.forEveryInstance((instance) => {
      instance.analysis.layers.selectedOnly.forEach((analysis) => {
        analysis.setDeselected();
      });
    });
  }
  onDeactivate() {
  }
  onCanvasLeave() {
  }
  onCanvasClick(x, y, file) {
    const newPoint = file.analysis.layers.createPointAt(x, y);
    newPoint.setSelected(true);
  }
  onPointDown() {
  }
  onPointUp(point) {
    if (!point.isInSelectedLayer()) {
      return;
    }
    point.deactivate();
    point.analysis.file.group.tool.selectTool("edit");
    point.analysis.ready = true;
    point.analysis.onMoveOrResize.call(point.analysis);
  }
  onPointMove() {
  }
  onPointLeave() {
  }
  onPointEnter() {
  }
  getLabelValue = (x, y, file) => {
    const temperature = file.group.tool.tools.inspect.getLabelValue(x, y, file);
    return `X:${x}<br />Y:${y}<br />${temperature}`;
  };
};

// src/properties/analysis/tool/internals/EditTool.ts
var EditTool = class extends AbstractTool {
  key = "edit";
  name = "editanalysis";
  description = "dragcornersofselectedanalysis";
  icon = `<?xml version="1.0" encoding="UTF-8"?>
<svg class="thermal-tool-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  <polygon points="34 17.03 34 -.02 30 -.02 30 17.03 17 17.03 17 32 0 32 0 36 17 36 17 47 46.97 47 46.97 17.03 34 17.03" fill="currentcolor"/>
</svg>`;
  onActivate() {
  }
  onDeactivate() {
  }
  onCanvasLeave() {
  }
  onCanvasClick() {
  }
  onPointEnter(point) {
    point.mouseEnter();
  }
  onPointLeave(point) {
    if (point.active === false) {
      point.mouseLeave();
    }
  }
  onPointMove(point, top, left) {
    if (point.isInSelectedLayer() && point.active) {
      point.setXFromTool(left);
      point.setYFromTool(top);
      point.analysis.onMoveOrResize.call(point.analysis);
    }
  }
  onPointDown(point) {
    if (point.isInSelectedLayer() && point.active === false) {
      point.activate();
    }
  }
  onPointUp(point) {
    if (point.active === true) {
      point.deactivate();
    }
  }
  getLabelValue(x, y, file) {
    const temperature = file.getTemperatureAtPoint(x, y);
    const hoveredAnalysis = file.analysis.layers.all.filter((analysis2) => analysis2.isWithin(x, y)).map((analysis2) => {
      const element = analysis2.selected ? "span" : "s";
      return `<${element} style="color: ${analysis2.initialColor};">
                    ${analysis2.name}
                </${element}>`;
    });
    const analysis = hoveredAnalysis.length > 0 ? hoveredAnalysis.join("<br />") + "<br />" : "";
    return `${analysis}${temperature && temperature.toFixed(2) + " \xB0C<br />"}X: ${x}<br />Y: ${y}`;
  }
};

// src/properties/analysis/tool/internals/InspectTool.ts
var InspectTool = class extends AbstractTool {
  key = "inspect";
  name = "inspecttemperatures";
  description = "usemousetoinspecttemperaturevalues";
  icon = `<?xml version="1.0" encoding="UTF-8"?>
<svg class="thermal-tool-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64">
  <path d="M17.58,42.03c-1.39,0-2.65-.34-3.79-1.01-1.14-.68-2.04-1.58-2.72-2.72-.68-1.14-1.01-2.4-1.01-3.78s.34-2.65,1.01-3.79c.67-1.14,1.58-2.04,2.72-2.72,1.14-.68,2.4-1.01,3.79-1.01s2.65.34,3.79,1.01c1.14.68,2.04,1.58,2.72,2.72s1.01,2.4,1.01,3.79-.34,2.64-1.01,3.78c-.68,1.14-1.58,2.05-2.72,2.72-1.14.68-2.4,1.01-3.79,1.01ZM17.58,37.04c.47,0,.9-.11,1.28-.34.38-.23.69-.53.91-.92.22-.39.34-.81.34-1.27s-.11-.9-.34-1.28c-.23-.38-.53-.69-.91-.91s-.81-.34-1.28-.34-.88.11-1.27.34c-.39.23-.69.53-.92.91-.23.38-.34.81-.34,1.28s.11.88.34,1.27c.22.39.53.69.92.92.39.23.81.34,1.27.34ZM56.24,38.45h-8.28c-.06-.69-.21-1.31-.46-1.87-.25-.56-.59-1.04-1.03-1.45-.44-.41-.96-.72-1.58-.94s-1.32-.33-2.1-.33c-1.37,0-2.53.33-3.47,1s-1.66,1.62-2.14,2.86-.73,2.74-.73,4.48c0,1.84.25,3.38.74,4.62s1.21,2.17,2.15,2.79c.94.62,2.07.93,3.39.93.75,0,1.43-.1,2.03-.29.6-.19,1.12-.47,1.56-.83.44-.36.8-.8,1.08-1.31.28-.51.47-1.09.57-1.74l8.28.06c-.1,1.27-.46,2.57-1.07,3.88-.62,1.32-1.49,2.53-2.62,3.64s-2.53,2-4.19,2.68c-1.67.68-3.6,1.01-5.8,1.01-2.76,0-5.24-.59-7.43-1.78-2.19-1.18-3.92-2.93-5.18-5.23-1.27-2.3-1.9-5.12-1.9-8.45s.65-6.17,1.94-8.47c1.29-2.3,3.04-4.03,5.23-5.21,2.19-1.18,4.64-1.77,7.34-1.77,1.9,0,3.65.26,5.24.78,1.6.52,3,1.28,4.2,2.27,1.2.99,2.17,2.22,2.91,3.66s1.18,3.11,1.34,4.98ZM30,0H0v30L30,0Z" fill="currentcolor"/>
</svg>`;
  onActivate() {
  }
  onDeactivate() {
  }
  onCanvasClick() {
  }
  onCanvasLeave() {
  }
  onPointEnter() {
  }
  onPointLeave() {
  }
  onPointMove() {
  }
  onPointDown() {
  }
  onPointUp() {
  }
  getLabelValue = (x, y, file) => {
    if (file === void 0) return "";
    try {
      return file.getTemperatureAtPoint(x, y).toFixed(2) + " \xB0C";
    } catch (err) {
      return "";
    }
  };
};

// src/properties/analysis/tool/ToolDrive.ts
var toolsRegistry = [
  InspectTool,
  AddPointTool,
  AddRectangleTool,
  AddEllipsisTool,
  EditTool
];
var createDefinedTools = (group) => {
  const arrayOfEntries = toolsRegistry.map((cls) => {
    const instance = new cls(group);
    return [
      instance.key,
      instance
    ];
  });
  return Object.fromEntries(arrayOfEntries);
};
var ToolDrive = class extends AbstractProperty {
  /** Create own set of tools from the registry of tools */
  _tools = createDefinedTools(this.parent);
  /** Readonly list of available tools */
  get tools() {
    return this._tools;
  }
  constructor(parent, initial) {
    super(parent, initial);
  }
  validate(value) {
    return value;
  }
  afterSetEffect(value) {
    if (value) {
      value.activate();
      Object.values(this.tools).forEach((tool) => {
        if (tool.key !== value.key) {
          tool.deactivate();
        }
      });
    }
  }
  /** Pick a tool. Its activation is handled by the `afterSetEffect` */
  selectTool(tool) {
    if (tool instanceof AbstractTool) {
      this.value = tool;
    } else {
      this.value = this.tools[tool];
    }
  }
};

// src/hierarchy/ThermalManager.ts
var ThermalManager = class extends BaseStructureObject {
  id;
  /** Service for creation of loading and caching the files. */
  service = new FilesService(this);
  /** Index of existing registries */
  registries = {};
  /** A palette is common to all registries within the manager */
  palette = new PaletteDrive(this, "jet");
  smooth = new SmoothDrive(this, false);
  graphSmooth = new GraphSmoothDrive(this, false);
  tool = new ToolDrive(this, new InspectTool(this));
  pool;
  constructor(pool4, options) {
    super();
    this.pool = pool4 ? pool4 : workerpool.pool();
    this.id = Math.random();
    if (options) {
      if (options.palette) {
        this.palette.setPalette(options.palette);
      }
    }
  }
  /* registries */
  forEveryRegistry(fn) {
    Object.values(this.registries).forEach((registry) => fn(registry));
  }
  addOrGetRegistry(id, options) {
    if (this.registries[id] === void 0) {
      this.registries[id] = new ThermalRegistry(id, this, options);
    }
    return this.registries[id];
  }
  removeRegistry(id) {
    if (this.registries[id] !== void 0) {
      const registry = this.registries[id];
      registry.destroySelfAndBelow();
      delete this.registries[id];
    }
  }
  filters = new FilterContainer(this);
  getInstances() {
    let instances = [];
    this.forEveryRegistry((registry) => {
      instances = [
        ...instances,
        ...registry.getInstances()
      ];
    });
    return instances;
  }
  forEveryInstance(callback) {
    this.forEveryRegistry((registry) => registry.forEveryInstance(callback));
  }
};

// src/utils/pool.ts
import * as workerpool2 from "workerpool";
var pool3 = void 0;
var getPool = async () => {
  if (!pool3) {
    pool3 = workerpool2.pool({
      maxWorkers: 6
    });
  }
  return pool3;
};
export {
  AbstractAnalysis,
  AbstractAreaAnalysis,
  AbstractFileResult,
  AbstractTool,
  AddEllipsisTool,
  AddRectangleTool,
  AnalysisGraph,
  CallbacksManager,
  CornerPoint,
  DropinElementListener,
  EditTool,
  EllipsisAnalysis,
  GRAYSCALE,
  IRON,
  InspectTool,
  Instance,
  JET,
  PointAnalysis,
  RectangleAnalysis,
  ThermalFileFailure,
  ThermalFileReader,
  ThermalGroup,
  ThermalManager,
  ThermalPalettes,
  ThermalRegistry,
  TimeFormat,
  TimePeriod,
  TimeRound,
  availableAnalysisColors,
  getPool,
  playbackSpeed,
  supportedFileTypes,
  supportedFileTypesInputProperty
};
