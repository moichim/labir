import { ThermalFileSource } from '../../file/ThermalFileSource';
import AbstractParser from '../AbstractParser';
import { LrcFrameParser } from './LrcFrameParser';
import { ILrcFrame } from './LrcTrame';
import { LrcUtils } from './LrcUtils';


/**
 * Parse the LRC file format.
 * 
 * LRC was created at NTC UWB in Pilsen. It is generated by thermal cameras LabIR Edu and by the analytical software LabIR.
 * 
 * **Binary format reference**
 * 
 * - 0  - 4 bity signature
 * - 4  - 1 bit version
 * - 5  - 10 bitů přeskočeno
 * - 14 - 1 bit streamType
 * - 15 - 1 bit streamUnits
 * - 17 - 2 bity width
 * - 19 - 2 bity height
 * - 21 - 4 bity přeskočeno
 * - 25 - 8 bitů timestamp
 * - 33 - 4 bity min
 * - 37 - 4 bity max
 * - 41 - 41 bitů přeskočeno
 * - 82 - začátek dat
 * 
 * Popis formátu souboru LRC verze 2		
		
Adresa	Datový typ	Význam
0	4x uint8	Signatura, vždy čtyři znaky "LRC\0"
4	uint8	Verze souboru, vždy 2
5	int64	Časová značka souboru
13	uint8	Počet externích zařízení, typicky 0
14	uint8	Počet streamů, typicky 1
15	uint8	Datový typ streamu 1
16	uint8	Jednotky streamu 1
17	uint16	Rozlišení teplotních dat, šířka
19	uint16	Rozlišení teplotních dat, výška
21	uint32	Příznaky dynamické části hlavičky, typicky 0
--- konec hlavičky souboru a začátek framu
25	int64	Časová značka snímku
33	float	Teplotní rozsah snímku, minimum; jednotky jsou podle streamu
37	float	Teplotní rozsah snímku, maximum; jednotky jsou podle streamu
41	float	Měřicí rozsah kamery, minimum [K]
45	float	Měřicí rozsah kamery, maximum [K]
49	float	Emisivita [0-1]
53	float	Odražená teplota [K]
57	float	Vzdálenost [m]
61	float	Teplota atmosféry [K]
65	float	Rel. vlhkost [0-1]
69	float	Tau (propustnost atmosféry) [0-1]
73	float	Teplota okénka [K]
77	float	Propustnost okénka [0-1]
81	uint8	Je tau nastaveno? Typicky 0, není nastaveno, počítá se z parametrů atmosféry.
82	podle streamu	Teplotní data
 * 
 * 
 */

export default class LrcParser extends AbstractParser {

    protected _signature?: string;
    protected _version?: number;
    protected _streamCount?: number;
    protected _fileDataType?: number;
    protected _pixelByteLength?: number;
    protected _unit?: number;


    protected async parseFile() {
        await this.parseSignature();
        this.parseVersion();
        this.parseDataType();
        this.parseStreamCount();
        this.parseTimestamp();
        this.parseUnit();
        this.parseWidth();
        this.parseHeight();
        this.parseFrameCount();
        this.parseFrames();
        // The following delends on frames
        this.parseMin();
        this.parseMax();
        await this.parsePixels();
    }


    // Signature
    protected isValidSignature = (value: string | undefined) => value === "LRC\0"
    protected async parseSignature() {
        const value = await this.readString(0, 4);
        if (!this.isValidSignature(value)) {
            this.logValidationError("signature", value);
        }
        this._signature = value;
    }

    // Version
    protected isValidVersion = (value: number | undefined) => value === 2;
    protected parseVersion() {
        const value = this.read8bNumber(4);
        if (!this.isValidVersion(value))
            this.logValidationError("version", value);
        this._version = value;
    }

    // Stream count
    // pro LRC z běžné kamery musí být vždy 1
    // Je-li streamů více, obsahují doplňkové údaje viz Unit
    protected isStreamCountValid = (value: number | undefined) => value === 1;
    protected parseStreamCount() {
        const value = this.read8bNumber(14);
        if (!this.isStreamCountValid(value))
            this.logValidationError("streamCount", value);
        this._streamCount = value;
    }


    // File data type
    // 0 = float16
    // 1 = float32 - tento je z LabIR Edu kamery
    // 2 = int16
    protected isDataTypeValid = (value: number | undefined) => value === undefined ? false : [0,1,2].includes( value );
    protected parseDataType() {
        const value = this.read8bNumber(15);
        if (!this.isDataTypeValid(value))
            this.logValidationError("fileDataType", value);
        this._fileDataType = value;
        // Assign pixel byte size depending on data type
        this._pixelByteLength = value === 0 ? 2 : 4;
    }

    /** Get byteSize of one pixel depending on the file data type */
    protected get pixelByteLength() {
        return this._pixelByteLength;
    }

    // Unit
    // 0 = none
    // 1 = intensity (surová data z termokamery - nelze přepočítat bez kalibrační křivky snímače)
    // 2 = stupně celsia
    // 3 = kelviny (přepočítat jednoduše)
    // 4 = čas (mimo kontext - neřešit)
    // 5 = úhel v radiánech čas (mimo kontext - neřešit)
    protected isValidUnit = (value: number | undefined) => value === 2;
    protected parseUnit() {
        const value = this.read8bNumber(16);
        if (!this.isValidUnit(value))
            this.logValidationError("unit", value);
        this._unit = value;
    }

    protected getFrameCount(): number {
        return this.getNumberOfFrames();    
    }


    // Min
    protected getMin(): number {

        return this.frames!.reduce( (state, current) => {

            if ( current.min < state ) {
                return current.min;
            }
            return state;

        }, Infinity );

    }

    protected getMax(): number {
        return this.frames!.reduce( (state, current) => {

            if ( current.max > state ) {
                return current.max;
            }
            return state;

        }, -Infinity );
    }




    // Width
    protected getWidth(): number {
        return this.read16bNumber(17);
    }

    // Height
    protected getHeight(): number {
        return this.read16bNumber(19);
    }

    // Read the file timestamp from index 5 (first frame timestamp is in index 25)
    protected getTimestamp(): number {

        return LrcUtils.readDotnetTimestamp( 5, this.data );

    }


    /** @todo Why must we add 4 bytes at the end of a frame? */
    protected getFrameSize() {
        if ( this._fileDataType === undefined || this.width === undefined || this.height === undefined || this.pixelByteLength === undefined ) {
            throw new Error( "Trying to read frame size before necessary attributes are known" );
        } else {

            const frameHeaderSize = 57;
            const dataSize = this.width * this.height * this.pixelByteLength;
            return frameHeaderSize + dataSize;

        }
    }

    protected getNumberOfFrames() {

        const frameSize = this.getFrameSize();

        return this.frameSubset.byteLength / frameSize;

    }

    

    protected getFrames() {

        const frames: ILrcFrame[] = [];
        
        const frameParser = new LrcFrameParser(
            this.frameSubset,
            this.width!,
            this.height!,
            this._fileDataType!,
            this.frameCount!,
            this.getFrameSize(),
            this.pixelByteLength!
        );

        for ( let i = 0; i < this.frameCount!; i++ ) {
            frames.push( frameParser.parseFrame(i) );
        }

        return frames;

    }




    /** @deprecated Should move to parsing from frames */
    protected async readTemperatureArray(index: number): Promise<number[]> {

        // Get the subset of bytes
        const subset = ( await this.blob.arrayBuffer() ).slice( index, index + ( this.width! * this.height! * this.pixelByteLength! ) );

        // UInt16 array needs to be converted to floats
        if ( this._fileDataType === 0 ) {

            const array = new Uint16Array( subset );

            const distance = Math.abs( this.min! - this.max! );
            const UINT16_MAX = 65535; // Math.pow( 2, 16 ) - 1;

            return [...array].map( pixel => {

                const mappedValue = pixel / UINT16_MAX;

                return this.min! + ( distance * mappedValue );

            } );

        } 
        // Float32 shall be outputted without modification
        else if ( this._fileDataType === 1 ) {
            
            return [ ...( new Float32Array( subset ) ) ]

        }

        return []

    }

    // Pixels
    protected getPixels() {

        if ( this.frames )
        if ( this.frames.length > 0 )
            return this.frames[0].pixels;

        return [];

    }

    

    isValid(): boolean {
        return this.errors.length === 0
            && this.isValidSignature(this._signature)
            && this.isStreamCountValid(this._streamCount)
            && this.isDataTypeValid(this._fileDataType)
            && this.isValidVersion(this._version)
            && this.isValidUnit(this._unit)
            && this.isValidTimestamp( this.timestamp )
            && this.isValidWidth( this.width )
            && this.isValidHeight( this.height )
            && this.isValidPixels( this.pixels )
            && this.isValidMin( this.min )
            && this.isValidMax( this.max )
            && this.isValidFrameCount( this.frameCount );
    }

    getThermalFile() {

        if (!this.isValid()) {
            throw new Error(
                this.encodeErrors()
            );
        }
        return new ThermalFileSource(
            this.url,
            this._signature!,
            this._version!,
            this._streamCount!,
            this._fileDataType!,
            this._unit!,
            this.width!,
            this.height!,
            this.timestamp!,
            this.pixels!,
            this.min!,
            this.max!,
            this.frameCount!,
            this.frames!,
            this.visibleUrl
        );
    }




    // Binary operations

    protected async readString(startIndex: number, stringLength: number): Promise<string> {
        return await this.blob.slice(startIndex, stringLength).text();
    }

    protected read16bNumber(index: number) {
        return this.data.getUint16(index, true);
    }

    protected read8bNumber(index: number): number {
        return this.data.getUint8(index);
    }



}