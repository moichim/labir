import { ThermalFileSource } from '../../file/ThermalFileSource';
import AbstractParser from '../AbstractParser';


/**
 * Parse the LRC file format.
 * 
 * LRC was created at NTC UWB in Pilsen. It is generated by thermal cameras LabIR Edu and by the analytical software LabIR.
 * 
 * **Binary format reference**
 * 
 * - 0  - 4 bity signature
 * - 4  - 1 bit version
 * - 5  - 10 bitů přeskočeno
 * - 14 - 1 bit streamType
 * - 15 - 1 bit streamUnits
 * - 17 - 2 bity width
 * - 19 - 2 bity height
 * - 21 - 4 bity přeskočeno
 * - 25 - 8 bitů timestamp
 * - 33 - 4 bity min
 * - 37 - 4 bity max
 * - 41 - 41 bitů přeskočeno
 * - 82 - začátek dat
 */

export default class LrcParser extends AbstractParser {

    protected _signature?: string;
    protected _version?: number;
    protected _streamCount?: number;
    protected _fileDataType?: number;
    protected _unit?: number;


    protected async parseFile() {
        await this.parseSignature();
        this.parseVersion();
        this.parseDataType();
        this.parseStreamCount();
        this.parseTimestamp();
        this.parseUnit();
        this.parseWidth();
        this.parseHeight();
        this.parseMin();
        this.parseMax();
        await this.parsePixels();
    }


    // Signature
    protected isValidSignature = (value: string | undefined) => value === "LRC\0"
    protected async parseSignature() {
        const value = await this.readString(0, 4);
        if (!this.isValidSignature(value)) {
            this.logValidationError("signature", value);
        }
        this._signature = value;
    }

    // Version
    protected isValidVersion = (value: number | undefined) => value === 2;
    protected parseVersion() {
        const value = this.read8bNumber(4);
        if (!this.isValidVersion(value))
            this.logValidationError("version", value);
        this._version = value;
    }

    // Stream count
    // pro LRC z běžné kamery musí být vždy 1
    // Je-li streamů více, obsahují doplňkové údaje viz Unit
    protected isStreamCountValid = (value: number | undefined) => value === 1;
    protected parseStreamCount() {
        const value = this.read8bNumber(14);
        if (!this.isStreamCountValid(value))
            this.logValidationError("streamCount", value);
        this._streamCount = value;
    }


    // File data type
    // 0 = float16
    // 1 = float32 - tento je z LabIR Edu kamery
    // 2 = int16
    protected isDataTypeValid = (value: number | undefined) => value === undefined ? false : [0,1,2].includes( value );
    protected parseDataType() {
        const value = this.read8bNumber(15);
        if (!this.isDataTypeValid(value))
            this.logValidationError("fileDataType", value);
        this._fileDataType = value;
    }

    // Unit
    // 0 = none
    // 1 = intensity (surová data z termokamery - nelze přepočítat bez kalibrační křivky snímače)
    // 2 = stupně celsia
    // 3 = kelviny (přepočítat jednoduše)
    // 4 = čas (mimo kontext - neřešit)
    // 5 = úhel v radiánech čas (mimo kontext - neřešit)
    protected isValidUnit = (value: number | undefined) => value === 2;
    protected parseUnit() {
        const value = this.read8bNumber(16);
        if (!this.isValidUnit(value))
            this.logValidationError("unit", value);
        this._unit = value;
    }




    // Width
    protected getWidth(): number {
        return this.read16bNumber(17);
    }

    // Height
    protected getHeight(): number {
        return this.read16bNumber(19);
    }

    // Timestamp
    protected getTimestamp(): number {


        const bigIntTime = this.data.getBigInt64(25, true);


        // Constant representing the Unix epoch in milliseconds
        const UnixEpoch: bigint = 62135596800000n;

        // Constants related to ticks (assuming ticks are stored as milliseconds)
        const TicksPerMillisecond: bigint = 10000n;
        const TicksPerDay: bigint = 24n * 60n * 60n * 1000n * TicksPerMillisecond;

        // Maximum value a 64-bit signed integer can hold
        const TicksCeiling: bigint = 0x4000000000000000n; // Assuming int64_t behaves like a signed 64-bit integer

        // Mask to extract the sign bit from a 64-bit unsigned integer
        const LocalMask: bigint = 0x8000000000000000n;

        // Mask to extract the tick value from a 64-bit unsigned integer
        const TicksMask: bigint = 0x3FFFFFFFFFFFFFFFn;



        let ticks = bigIntTime & TicksMask;

        const isLocalTime = bigIntTime & LocalMask;

        if (isLocalTime) {

            if (ticks > (TicksCeiling - TicksPerDay)) {
                ticks -= TicksCeiling;
            }

            if (ticks < 0) {
                ticks += TicksPerDay;
            }

        }

        // the time is UTC, needs to be converted to local time zone
        const milliseconds = ticks / TicksPerMillisecond - UnixEpoch;

        return Number(milliseconds)


    }



    protected async readTemperatureArray(index: number): Promise<number[]> {

        // Get the subset of bytes
        const subset = ( await this.blob.arrayBuffer() ).slice( index );

        // UInt16 array needs to be converted to floats
        if ( this._fileDataType === 0 ) {

            const array = new Uint16Array( subset );

            const distance = Math.abs( this.min! - this.max! );
            const UINT16_MAX = 65535; // Math.pow( 2, 16 ) - 1;

            return [...array].map( pixel => {

                const mappedValue = pixel / UINT16_MAX;

                return this.min! + ( distance * mappedValue );

            } );

        } 
        // Float32 shall be outputted without modification
        else if ( this._fileDataType === 1 ) {
            
            return [ ...( new Float32Array( subset ) ) ]

        }

        return []

    }

    // Pixels
    protected getPixels() {
        return this.readTemperatureArray(82);
    }

    // Min
    protected getMin(): number {
        return this.data.getFloat32(33, true);
    }

    protected getMax(): number {
        return this.data.getFloat32(37, true);
    }

    isValid(): boolean {
        return this.errors.length === 0
            && this.isValidSignature(this._signature)
            && this.isStreamCountValid(this._streamCount)
            && this.isDataTypeValid(this._fileDataType)
            && this.isValidVersion(this._version)
            && this.isValidUnit(this._unit)
            && this.isValidTimestamp( this.timestamp )
            && this.isValidWidth( this.width )
            && this.isValidHeight( this.height )
            && this.isValidPixels( this.pixels )
            && this.isValidMin( this.min )
            && this.isValidMax( this.max );
    }

    getThermalFile() {
        if (!this.isValid()) {
            console.error(this.getErrors());
            return null;
        }
        return new ThermalFileSource(
            this.url,
            this._signature!,
            this._version!,
            this._streamCount!,
            this._fileDataType!,
            this._unit!,
            this.width!,
            this.height!,
            this.timestamp!,
            this.pixels!,
            this.min!,
            this.max!,
            this.visibleUrl
        );
    }




    // Binary operations

    protected async readString(startIndex: number, stringLength: number): Promise<string> {
        return await this.blob.slice(startIndex, stringLength).text();
    }

    protected read16bNumber(index: number) {
        return this.data.getUint16(index, true);
    }

    protected read8bNumber(index: number): number {
        return this.data.getUint8(index);
    }



}